File "lake-edhoc-KEM-KEM-anony.pv", line 394, characters 19-23:
Warning: identifier pkI_2 rebound.
Linear part: No equation.
Convergent part:
kemdecap(kemcipher(kemencap(r,kempk(sk))),sk) = kemkey(kemencap(r,kempk(sk)))
fst((x_1,x_2)) = x_1
snd((x_1,x_2)) = x_2
Completing equations...
Completed equations:
snd((x_1,x_2)) = x_2
fst((x_1,x_2)) = x_1
kemdecap(kemcipher(kemencap(r,kempk(sk))),sk) = kemkey(kemencap(r,kempk(sk)))
Biprocess 0 (that is, the initial process):
{1}!
{2}new computerId_1: bitstring;
{3}new sk_1: bitstring;
{4}new sk_auth_kem_1: bitstring;
{5}new ltdh_1: bitstring;
{6}let idd_1: bitstring = id(pk(sk_1),ltdh_1,kempk(sk_auth_kem_1)) in
{7}out(att, (idd_1,(pk(sk_1),ltdh_1,kempk(sk_auth_kem_1))));
{8}event eShareLT(ltdh_1);
{9}event eHonest(pk(sk_1));
{10}event eHonest(kempk(sk_auth_kem_1));
{11}new sk_2: bitstring;
{12}new sk_auth_kem_2: bitstring;
{13}new ltdh_2: bitstring;
{14}new computerId_2: bitstring;
{15}let idd_2: bitstring = id(pk(sk_2),ltdh_2,kempk(sk_auth_kem_2)) in
{16}out(att, (idd_2,(pk(sk_2),ltdh_2,kempk(sk_auth_kem_2))));
{17}event eShareLT(ltdh_2);
{18}event eHonest(pk(sk_2));
{19}event eHonest(kempk(sk_auth_kem_2));
(
    {20}!
    {21}in(att, cred_2: bitstring);
    {22}let cid_2: bitstring = computerId_1 in
    {23}let skI_2: bitstring = sk_1 in
    {24}let I_2: bitstring = ltdh_1 in
    {25}let sk_kem_authI: bitstring = sk_auth_kem_1 in
    {26}in(att, (method_2: bitstring,(suitesI_2: bitstring,(C_I_2: bitstring,EAD_1_2: bitstring))));
    {27}event eMethodOk(method_2);
    {28}new X_2: bitstring;
    {29}new random_authR: bitstring;
    {30}new EAD_3_2: bitstring;
    {31}event eShare(X_2);
    {32}let CRED_I_2: bitstring = pk(skI_2) in
    {33}let KEM_CRED_I_2: bitstring = kempk(sk_kem_authI) in
    {34}let ID_CRED_I_2: bitstring = id(CRED_I_2,I_2,KEM_CRED_I_2) in
    {35}if (ID_CRED_I_2 ≠ check_cred(cred_2)) then
    {36}if (method_2 = method_four) then
    {37}let pkR_2: bitstring = get_kem_auth(cred_2) in
    {38}let encap_auth_R_2: bitstring = kemencap(random_authR,pkR_2) in
    {39}let K_AUTH_R_2: bitstring = kemkey(encap_auth_R_2) in
    {40}let CT_AUTH_R_2: bitstring = kemcipher(encap_auth_R_2) in
    {41}let plaintext_1_2: bitstring = ID_CRED_I_2 in
    {42}let G_X_2: bitstring = kempk(X_2) in
    {43}let TH_1_2: bitstring = hash((G_X_2,CT_AUTH_R_2)) in
    {44}let PRK_1e_2: bitstring = hkdfextract(TH_1_2,K_AUTH_R_2) in
    {45}let K_1_2: bitstring = edhoc_kdf(PRK_1e_2,szero,TH_1_2,key_length) in
    {46}let IV_1_2: bitstring = edhoc_kdf(PRK_1e_2,sone,TH_1_2,iv_length) in
    {47}let CIPHERTEXT_1_2: bitstring = aeadenc(plaintext_1_2,srep,K_1_2,IV_1_2) in
    {48}let m1_2: bitstring = (method_2,suitesI_2,G_X_2,C_I_2,EAD_1_2) in
    {49}out(att, m1_2);
    {50}in(att, m2_2: bitstring);
    {51}let (G_Y_2: bitstring,CIPHERTEXT_2_2: bitstring,CT_AUTH_I_2: bitstring) = m2_2 in
    {52}let mess_1_hash_2: bitstring = hash(m1_2) in
    {53}let TH_2_2: bitstring = hash((G_Y_2,mess_1_hash_2)) in
    {54}let G_YX_2: bitstring = kemdecap(G_Y_2,X_2) in
    {55}let PRK_2e_2: bitstring = hkdfextract(TH_2_2,G_YX_2) in
    {56}let KEYSTREAM_2_2: bitstring = edhoc_kdf(PRK_2e_2,stwo,TH_2_2,plaintext_length) in
    {57}let plaintext_2_2: bitstring = decxor(CIPHERTEXT_2_2,KEYSTREAM_2_2) in
    {58}let (C_R_2: bitstring,=cred_2,SIGNATURE_or_MAC_2_2: bitstring,EAD_2_2: bitstring) = plaintext_2_2 in
    {59}let pkI_2: bitstring = get_kem_auth(ID_CRED_I_2) in
    {60}let SALT_3e2m_2: bitstring = edhoc_kdf(PRK_2e_2,sthree,TH_2_2,hash_length) in
    {61}let PRK_3e2m_2: bitstring = hkdfextract(SALT_3e2m_2,K_AUTH_R_2) in
    {62}event eDerivedIShared(pkI_2,G_YX_2);
    {63}let MAC_2_2: bitstring = edhoc_kdf(PRK_3e2m_2,sfour,(cred_2,TH_2_2,pkR_2,EAD_2_2),hash_length) in
    {64}if (SIGNATURE_or_MAC_2_2 = MAC_2_2) then
    {65}event eCheckedMAC2(ID_CRED_I_2,MAC_2_2);
    {66}let TH_3_2: bitstring = hash((TH_2_2,(plaintext_2_2,pkR_2))) in
    {67}event eTHIShared(pkI_2,TH_3_2);
    {68}let K_3_2: bitstring = edhoc_kdf(PRK_3e2m_2,sfive,TH_3_2,key_length) in
    {69}let IV_3_2: bitstring = edhoc_kdf(PRK_3e2m_2,ssix,TH_3_2,iv_length) in
    {70}let SALT_4e3m_2: bitstring = edhoc_kdf(PRK_3e2m_2,sseven,TH_3_2,hash_length) in
    {71}let K_AUTH_I_2: bitstring = kemdecap(CT_AUTH_I_2,sk_kem_authI) in
    {72}let PRK_4e3m_2: bitstring = hkdfextract(SALT_4e3m_2,K_AUTH_I_2) in
    {73}let MAC_3_2: bitstring = edhoc_kdf(PRK_4e3m_2,seight,(ID_CRED_I_2,TH_3_2,pkI_2,EAD_3_2),hash_length) in
    {74}let SIGNATURE_or_MAC_3_2: bitstring = MAC_3_2 in
    {75}let plaintext_3_2: bitstring = (ID_CRED_I_2,(SIGNATURE_or_MAC_3_2,EAD_3_2)) in
    {76}let m3_2: bitstring = aeadenc(plaintext_3_2,srep,K_3_2,IV_3_2) in
    {77}let TH_4_2: bitstring = hash((TH_3_2,(plaintext_3_2,pkI_2))) in
    {78}let PRK_out_2: bitstring = edhoc_kdf(PRK_4e3m_2,snine,TH_4_2,hash_length) in
    {79}event eAcceptI(cid_2,method_four,pkI_2,pkR_2,PRK_3e2m_2,PRK_4e3m_2,PRK_out_2,X_2,G_Y_2);
    {80}event eSecretsI(cid_2,method_four,pkI_2,pkR_2,PRK_2e_2,PRK_3e2m_2,PRK_4e3m_2,PRK_out_2,KEYSTREAM_2_2,K_3_2,IV_3_2,X_2,G_Y_2);
    {81}event eAcceptIData(PRK_out_2,method_four,pkI_2,pkR_2,X_2,G_Y_2,(TH_1_2,TH_2_2,(TH_3_2,(TH_4_2,(suitesI_2,(EAD_1_2,(EAD_2_2,(EAD_3_2,(m1_2,(plaintext_1_2,plaintext_2_2,plaintext_3_2))))))))));
    (
        {82}out(att, m3_2)
    ) | (
        {83}event eLeakSessionKey(PRK_out_2);
        {84}out(att, PRK_out_2)
    )
) | (
    {85}!
    {86}in(att, cred_3: bitstring);
    {87}let cid: bitstring = computerId_2 in
    {88}let skI: bitstring = sk_2 in
    {89}let I_1: bitstring = ltdh_2 in
    {90}let sk_kem_authI_1: bitstring = sk_auth_kem_2 in
    {91}in(att, (method: bitstring,(suitesI: bitstring,(C_I: bitstring,EAD_1: bitstring))));
    {92}event eMethodOk(method);
    {93}new X: bitstring;
    {94}new random_authR_1: bitstring;
    {95}new EAD_3: bitstring;
    {96}event eShare(X);
    {97}let CRED_I: bitstring = pk(skI) in
    {98}let KEM_CRED_I: bitstring = kempk(sk_kem_authI_1) in
    {99}let ID_CRED_I: bitstring = id(CRED_I,I_1,KEM_CRED_I) in
    {100}if (ID_CRED_I ≠ check_cred(cred_3)) then
    {101}if (method = method_four) then
    {102}let pkR: bitstring = get_kem_auth(cred_3) in
    {103}let encap_auth_R: bitstring = kemencap(random_authR_1,pkR) in
    {104}let K_AUTH_R: bitstring = kemkey(encap_auth_R) in
    {105}let CT_AUTH_R: bitstring = kemcipher(encap_auth_R) in
    {106}let plaintext_1: bitstring = ID_CRED_I in
    {107}let G_X: bitstring = kempk(X) in
    {108}let TH_1: bitstring = hash((G_X,CT_AUTH_R)) in
    {109}let PRK_1e: bitstring = hkdfextract(TH_1,K_AUTH_R) in
    {110}let K_1: bitstring = edhoc_kdf(PRK_1e,szero,TH_1,key_length) in
    {111}let IV_1: bitstring = edhoc_kdf(PRK_1e,sone,TH_1,iv_length) in
    {112}let CIPHERTEXT_1: bitstring = aeadenc(plaintext_1,srep,K_1,IV_1) in
    {113}let m1: bitstring = (method,suitesI,G_X,C_I,EAD_1) in
    {114}out(att, m1);
    {115}in(att, m2: bitstring);
    {116}let (G_Y: bitstring,CIPHERTEXT_2: bitstring,CT_AUTH_I: bitstring) = m2 in
    {117}let mess_1_hash: bitstring = hash(m1) in
    {118}let TH_2: bitstring = hash((G_Y,mess_1_hash)) in
    {119}let G_YX: bitstring = kemdecap(G_Y,X) in
    {120}let PRK_2e: bitstring = hkdfextract(TH_2,G_YX) in
    {121}let KEYSTREAM_2: bitstring = edhoc_kdf(PRK_2e,stwo,TH_2,plaintext_length) in
    {122}let plaintext_2: bitstring = decxor(CIPHERTEXT_2,KEYSTREAM_2) in
    {123}let (C_R: bitstring,=cred_3,SIGNATURE_or_MAC_2: bitstring,EAD_2: bitstring) = plaintext_2 in
    {124}let pkI: bitstring = get_kem_auth(ID_CRED_I) in
    {125}let SALT_3e2m: bitstring = edhoc_kdf(PRK_2e,sthree,TH_2,hash_length) in
    {126}let PRK_3e2m: bitstring = hkdfextract(SALT_3e2m,K_AUTH_R) in
    {127}event eDerivedIShared(pkI,G_YX);
    {128}let MAC_2: bitstring = edhoc_kdf(PRK_3e2m,sfour,(cred_3,TH_2,pkR,EAD_2),hash_length) in
    {129}if (SIGNATURE_or_MAC_2 = MAC_2) then
    {130}event eCheckedMAC2(ID_CRED_I,MAC_2);
    {131}let TH_3: bitstring = hash((TH_2,(plaintext_2,pkR))) in
    {132}event eTHIShared(pkI,TH_3);
    {133}let K_3: bitstring = edhoc_kdf(PRK_3e2m,sfive,TH_3,key_length) in
    {134}let IV_3: bitstring = edhoc_kdf(PRK_3e2m,ssix,TH_3,iv_length) in
    {135}let SALT_4e3m: bitstring = edhoc_kdf(PRK_3e2m,sseven,TH_3,hash_length) in
    {136}let K_AUTH_I: bitstring = kemdecap(CT_AUTH_I,sk_kem_authI_1) in
    {137}let PRK_4e3m: bitstring = hkdfextract(SALT_4e3m,K_AUTH_I) in
    {138}let MAC_3: bitstring = edhoc_kdf(PRK_4e3m,seight,(ID_CRED_I,TH_3,pkI,EAD_3),hash_length) in
    {139}let SIGNATURE_or_MAC_3: bitstring = MAC_3 in
    {140}let plaintext_3: bitstring = (ID_CRED_I,(SIGNATURE_or_MAC_3,EAD_3)) in
    {141}let m3: bitstring = aeadenc(plaintext_3,srep,K_3,IV_3) in
    {142}let TH_4: bitstring = hash((TH_3,(plaintext_3,pkI))) in
    {143}let PRK_out: bitstring = edhoc_kdf(PRK_4e3m,snine,TH_4,hash_length) in
    {144}event eAcceptI(cid,method_four,pkI,pkR,PRK_3e2m,PRK_4e3m,PRK_out,X,G_Y);
    {145}event eSecretsI(cid,method_four,pkI,pkR,PRK_2e,PRK_3e2m,PRK_4e3m,PRK_out,KEYSTREAM_2,K_3,IV_3,X,G_Y);
    {146}event eAcceptIData(PRK_out,method_four,pkI,pkR,X,G_Y,(TH_1,TH_2,(TH_3,(TH_4,(suitesI,(EAD_1,(EAD_2,(EAD_3,(m1,(plaintext_1,plaintext_2,plaintext_3))))))))));
    (
        {147}out(att, m3)
    ) | (
        {148}event eLeakSessionKey(PRK_out);
        {149}out(att, PRK_out)
    )
) | (
    {150}!
    {151}let cid_1: bitstring = computerId_1 in
    {152}let skR_2: bitstring = sk_1 in
    {153}let R_2: bitstring = ltdh_1 in
    {154}let sk_kem_authR_2: bitstring = sk_auth_kem_1 in
    {155}in(att, (C_R_1: bitstring,(EAD_2_1: bitstring,suitesR_2: bitstring)));
    {156}in(att, m1_1: bitstring);
    {157}let (method_1: bitstring,suitesI_1: bitstring,G_X_1: bitstring,C_I_1: bitstring,CT_AUTH_R_1: bitstring,CIPHERTEXT_1_1: bitstring,EAD_1_1: bitstring) = m1_1 in
    {158}event eMethodOk(method_1);
    {159}new Y_2: bitstring;
    {160}event eShare(Y_2);
    {161}let G_R_2: bitstring = R_2 in
    {162}let encapsulation: bitstring = kemencap(Y_2,G_X_1) in
    {163}let G_Y_1: bitstring = kemcipher(encapsulation) in
    {164}let G_XY_2: bitstring = kemkey(encapsulation) in
    {165}let CRED_R_2: bitstring = pk(skR_2) in
    {166}let KEM_CRED_R_2: bitstring = kempk(sk_kem_authR_2) in
    {167}let ID_CRED_R_2: bitstring = id(CRED_R_2,G_R_2,KEM_CRED_R_2) in
    {168}if (method_1 = method_four) then
    {169}let K_AUTH_R_1: bitstring = kemdecap(CT_AUTH_R_1,sk_kem_authR_2) in
    {170}let TH_1_1: bitstring = hash((G_X_1,CT_AUTH_R_1)) in
    {171}let PRK_1e_1: bitstring = hkdfextract(TH_1_1,K_AUTH_R_1) in
    {172}let K_1_1: bitstring = edhoc_kdf(PRK_1e_1,szero,TH_1_1,key_length) in
    {173}let IV_1_1: bitstring = edhoc_kdf(PRK_1e_1,sone,TH_1_1,iv_length) in
    {174}let plaintext_1_1: bitstring = aeaddec(CIPHERTEXT_1_1,K_1_1,IV_1_1) in
    {175}let ID_CRED_I_1: bitstring = plaintext_1_1 in
    {176}if (ID_CRED_R_2 ≠ check_cred(ID_CRED_I_1)) then
    {177}let mess_1_hash_1: bitstring = hash(m1_1) in
    {178}let TH_2_1: bitstring = hash((G_Y_1,mess_1_hash_1)) in
    {179}let PRK_2e_1: bitstring = hkdfextract(TH_2_1,G_XY_2) in
    {180}let pkR_1: bitstring = get_kem_auth(ID_CRED_R_2) in
    {181}let pkI_1: bitstring = get_kem_auth(ID_CRED_I_1) in
    {182}let KEYSTREAM_2_1: bitstring = edhoc_kdf(PRK_2e_1,stwo,TH_2_1,plaintext_length) in
    {183}let SALT_3e2m_1: bitstring = edhoc_kdf(PRK_2e_1,sthree,TH_2_1,hash_length) in
    {184}let PRK_3e2m_1: bitstring = hkdfextract(SALT_3e2m_1,K_AUTH_R_1) in
    {185}let MAC_2_1: bitstring = edhoc_kdf(PRK_3e2m_1,sfour,(ID_CRED_R_2,TH_2_1,pkR_1,EAD_2_1),hash_length) in
    {186}let SIGNATURE_or_MAC_2_1: bitstring = MAC_2_1 in
    {187}let plaintext_2_1: bitstring = (C_R_1,(ID_CRED_R_2,(SIGNATURE_or_MAC_2_1,EAD_2_1))) in
    {188}event eDerivedR(cid_1,pkR_1,PRK_3e2m_1,Y_2,G_X_1);
    {189}event eTHRShared(pkR_1,TH_2_1);
    {190}event eDerivedRShared(pkR_1,G_XY_2);
    {191}event eDerivedIdR(ID_CRED_R_2,PRK_3e2m_1);
    {192}new encap_auth_random_seed: bitstring;
    {193}let encap_auth_I_2: bitstring = kemencap(encap_auth_random_seed,pkI_1) in
    {194}let K_AUTH_I_1: bitstring = kemkey(encap_auth_I_2) in
    {195}let CT_AUTH_I_1: bitstring = kemcipher(encap_auth_I_2) in
    {196}let m2_1: bitstring = (G_Y_1,encxor(plaintext_2_1,KEYSTREAM_2_1)) in
    {197}event eSendRData(method_four,pkR_1,(TH_1_1,TH_2_1,(suitesI_1,(EAD_1_1,(EAD_2_1,(m1_1,plaintext_1_1,plaintext_2_1))))));
    {198}out(att, m2_1);
    {199}in(att, CIPHERTEXT_3_2: bitstring);
    {200}let TH_3_1: bitstring = hash((TH_2_1,(plaintext_2_1,pkR_1))) in
    {201}let K_3_1: bitstring = edhoc_kdf(PRK_3e2m_1,sfive,TH_3_1,key_length) in
    {202}let IV_3_1: bitstring = edhoc_kdf(PRK_3e2m_1,ssix,TH_3_1,iv_length) in
    {203}let SALT_4e3m_1: bitstring = edhoc_kdf(PRK_3e2m_1,sseven,TH_3_1,hash_length) in
    {204}let PRK_4e3m_1: bitstring = hkdfextract(SALT_4e3m_1,K_AUTH_I_1) in
    {205}let plaintext_3_1: bitstring = aeaddec(CIPHERTEXT_3_2,K_3_1,IV_3_1) in
    {206}let (=ID_CRED_I_1,(SIGNATURE_or_MAC_3_1: bitstring,EAD_3_1: bitstring)) = plaintext_3_1 in
    {207}let pkI_3: bitstring = get_kem_auth(ID_CRED_I_1) in
    {208}let MAC_3_1: bitstring = edhoc_kdf(PRK_4e3m_1,seight,(ID_CRED_I_1,TH_3_1,pkI_3,EAD_3_1),hash_length) in
    {209}if (SIGNATURE_or_MAC_3_1 = MAC_3_1) then
    {210}event eCheckedMAC3(ID_CRED_R_2,MAC_3_1);
    {211}let TH_4_1: bitstring = hash((TH_3_1,(plaintext_3_1,pkI_3))) in
    {212}let PRK_out_1: bitstring = edhoc_kdf(PRK_4e3m_1,snine,TH_4_1,hash_length) in
    {213}event eAcceptR(cid_1,method_four,pkI_3,pkR_1,PRK_3e2m_1,PRK_4e3m_1,PRK_out_1,Y_2,G_X_1);
    {214}event eSecretsR(cid_1,method_four,pkI_3,pkR_1,PRK_2e_1,PRK_3e2m_1,PRK_4e3m_1,PRK_out_1,KEYSTREAM_2_1,K_3_1,IV_3_1,Y_2,G_X_1);
    (
        {215}event eAcceptRData(PRK_out_1,method_four,pkI_3,pkR_1,Y_2,G_X_1,(TH_1_1,TH_2_1,(TH_3_1,(TH_4_1,(suitesI_1,(EAD_1_1,(EAD_2_1,(EAD_3_1,(m1_1,(plaintext_1_1,plaintext_2_1,plaintext_3_1))))))))))
    ) | (
        {216}event eLeakSessionKey(PRK_out_1);
        {217}out(att, PRK_out_1)
    )
) | (
    {218}!
    {219}let cid_3: bitstring = computerId_2 in
    {220}let skR: bitstring = sk_2 in
    {221}let R_1: bitstring = ltdh_2 in
    {222}let sk_kem_authR: bitstring = sk_auth_kem_2 in
    {223}in(att, (C_R_3: bitstring,(EAD_2_3: bitstring,suitesR: bitstring)));
    {224}in(att, m1_3: bitstring);
    {225}let (method_3: bitstring,suitesI_3: bitstring,G_X_3: bitstring,C_I_3: bitstring,CT_AUTH_R_3: bitstring,CIPHERTEXT_1_3: bitstring,EAD_1_3: bitstring) = m1_3 in
    {226}event eMethodOk(method_3);
    {227}new Y: bitstring;
    {228}event eShare(Y);
    {229}let G_R: bitstring = R_1 in
    {230}let encapsulation_1: bitstring = kemencap(Y,G_X_3) in
    {231}let G_Y_3: bitstring = kemcipher(encapsulation_1) in
    {232}let G_XY: bitstring = kemkey(encapsulation_1) in
    {233}let CRED_R: bitstring = pk(skR) in
    {234}let KEM_CRED_R: bitstring = kempk(sk_kem_authR) in
    {235}let ID_CRED_R: bitstring = id(CRED_R,G_R,KEM_CRED_R) in
    {236}if (method_3 = method_four) then
    {237}let K_AUTH_R_3: bitstring = kemdecap(CT_AUTH_R_3,sk_kem_authR) in
    {238}let TH_1_3: bitstring = hash((G_X_3,CT_AUTH_R_3)) in
    {239}let PRK_1e_3: bitstring = hkdfextract(TH_1_3,K_AUTH_R_3) in
    {240}let K_1_3: bitstring = edhoc_kdf(PRK_1e_3,szero,TH_1_3,key_length) in
    {241}let IV_1_3: bitstring = edhoc_kdf(PRK_1e_3,sone,TH_1_3,iv_length) in
    {242}let plaintext_1_3: bitstring = aeaddec(CIPHERTEXT_1_3,K_1_3,IV_1_3) in
    {243}let ID_CRED_I_3: bitstring = plaintext_1_3 in
    {244}if (ID_CRED_R ≠ check_cred(ID_CRED_I_3)) then
    {245}let mess_1_hash_3: bitstring = hash(m1_3) in
    {246}let TH_2_3: bitstring = hash((G_Y_3,mess_1_hash_3)) in
    {247}let PRK_2e_3: bitstring = hkdfextract(TH_2_3,G_XY) in
    {248}let pkR_3: bitstring = get_kem_auth(ID_CRED_R) in
    {249}let pkI_4: bitstring = get_kem_auth(ID_CRED_I_3) in
    {250}let KEYSTREAM_2_3: bitstring = edhoc_kdf(PRK_2e_3,stwo,TH_2_3,plaintext_length) in
    {251}let SALT_3e2m_3: bitstring = edhoc_kdf(PRK_2e_3,sthree,TH_2_3,hash_length) in
    {252}let PRK_3e2m_3: bitstring = hkdfextract(SALT_3e2m_3,K_AUTH_R_3) in
    {253}let MAC_2_3: bitstring = edhoc_kdf(PRK_3e2m_3,sfour,(ID_CRED_R,TH_2_3,pkR_3,EAD_2_3),hash_length) in
    {254}let SIGNATURE_or_MAC_2_3: bitstring = MAC_2_3 in
    {255}let plaintext_2_3: bitstring = (C_R_3,(ID_CRED_R,(SIGNATURE_or_MAC_2_3,EAD_2_3))) in
    {256}event eDerivedR(cid_3,pkR_3,PRK_3e2m_3,Y,G_X_3);
    {257}event eTHRShared(pkR_3,TH_2_3);
    {258}event eDerivedRShared(pkR_3,G_XY);
    {259}event eDerivedIdR(ID_CRED_R,PRK_3e2m_3);
    {260}new encap_auth_random_seed_1: bitstring;
    {261}let encap_auth_I: bitstring = kemencap(encap_auth_random_seed_1,pkI_4) in
    {262}let K_AUTH_I_3: bitstring = kemkey(encap_auth_I) in
    {263}let CT_AUTH_I_3: bitstring = kemcipher(encap_auth_I) in
    {264}let m2_3: bitstring = (G_Y_3,encxor(plaintext_2_3,KEYSTREAM_2_3)) in
    {265}event eSendRData(method_four,pkR_3,(TH_1_3,TH_2_3,(suitesI_3,(EAD_1_3,(EAD_2_3,(m1_3,plaintext_1_3,plaintext_2_3))))));
    {266}out(att, m2_3);
    {267}in(att, CIPHERTEXT_3: bitstring);
    {268}let TH_3_3: bitstring = hash((TH_2_3,(plaintext_2_3,pkR_3))) in
    {269}let K_3_3: bitstring = edhoc_kdf(PRK_3e2m_3,sfive,TH_3_3,key_length) in
    {270}let IV_3_3: bitstring = edhoc_kdf(PRK_3e2m_3,ssix,TH_3_3,iv_length) in
    {271}let SALT_4e3m_3: bitstring = edhoc_kdf(PRK_3e2m_3,sseven,TH_3_3,hash_length) in
    {272}let PRK_4e3m_3: bitstring = hkdfextract(SALT_4e3m_3,K_AUTH_I_3) in
    {273}let plaintext_3_3: bitstring = aeaddec(CIPHERTEXT_3,K_3_3,IV_3_3) in
    {274}let (=ID_CRED_I_3,(SIGNATURE_or_MAC_3_3: bitstring,EAD_3_3: bitstring)) = plaintext_3_3 in
    {275}let pkI_5: bitstring = get_kem_auth(ID_CRED_I_3) in
    {276}let MAC_3_3: bitstring = edhoc_kdf(PRK_4e3m_3,seight,(ID_CRED_I_3,TH_3_3,pkI_5,EAD_3_3),hash_length) in
    {277}if (SIGNATURE_or_MAC_3_3 = MAC_3_3) then
    {278}event eCheckedMAC3(ID_CRED_R,MAC_3_3);
    {279}let TH_4_3: bitstring = hash((TH_3_3,(plaintext_3_3,pkI_5))) in
    {280}let PRK_out_3: bitstring = edhoc_kdf(PRK_4e3m_3,snine,TH_4_3,hash_length) in
    {281}event eAcceptR(cid_3,method_four,pkI_5,pkR_3,PRK_3e2m_3,PRK_4e3m_3,PRK_out_3,Y,G_X_3);
    {282}event eSecretsR(cid_3,method_four,pkI_5,pkR_3,PRK_2e_3,PRK_3e2m_3,PRK_4e3m_3,PRK_out_3,KEYSTREAM_2_3,K_3_3,IV_3_3,Y,G_X_3);
    (
        {283}event eAcceptRData(PRK_out_3,method_four,pkI_5,pkR_3,Y,G_X_3,(TH_1_3,TH_2_3,(TH_3_3,(TH_4_3,(suitesI_3,(EAD_1_3,(EAD_2_3,(EAD_3_3,(m1_3,(plaintext_1_3,plaintext_2_3,plaintext_3_3))))))))))
    ) | (
        {284}event eLeakSessionKey(PRK_out_3);
        {285}out(att, PRK_out_3)
    )
) | (
    {286}!
    {287}let cid_4: bitstring = choice[computerId_1,computerId_2] in
    {288}let skI_1: bitstring = choice[sk_1,sk_2] in
    {289}let I_3: bitstring = choice[ltdh_1,ltdh_2] in
    {290}let sk_kem_authI_2: bitstring = choice[sk_auth_kem_1,sk_auth_kem_2] in
    {291}in(att, (method_4: bitstring,(suitesI_4: bitstring,(C_I_4: bitstring,EAD_1_4: bitstring))));
    {292}event eMethodOk(method_4);
    {293}new X_1: bitstring;
    {294}new random_authR_2: bitstring;
    {295}new EAD_3_4: bitstring;
    {296}event eShare(X_1);
    {297}let CRED_I_1: bitstring = pk(skI_1) in
    {298}let KEM_CRED_I_1: bitstring = kempk(sk_kem_authI_2) in
    {299}let ID_CRED_I_4: bitstring = id(CRED_I_1,I_3,KEM_CRED_I_1) in
    {300}if (ID_CRED_I_4 ≠ check_cred(idd_2)) then
    {301}if (method_4 = method_four) then
    {302}let pkR_4: bitstring = get_kem_auth(idd_2) in
    {303}let encap_auth_R_1: bitstring = kemencap(random_authR_2,pkR_4) in
    {304}let K_AUTH_R_4: bitstring = kemkey(encap_auth_R_1) in
    {305}let CT_AUTH_R_4: bitstring = kemcipher(encap_auth_R_1) in
    {306}let plaintext_1_4: bitstring = ID_CRED_I_4 in
    {307}let G_X_4: bitstring = kempk(X_1) in
    {308}let TH_1_4: bitstring = hash((G_X_4,CT_AUTH_R_4)) in
    {309}let PRK_1e_4: bitstring = hkdfextract(TH_1_4,K_AUTH_R_4) in
    {310}let K_1_4: bitstring = edhoc_kdf(PRK_1e_4,szero,TH_1_4,key_length) in
    {311}let IV_1_4: bitstring = edhoc_kdf(PRK_1e_4,sone,TH_1_4,iv_length) in
    {312}let CIPHERTEXT_1_4: bitstring = aeadenc(plaintext_1_4,srep,K_1_4,IV_1_4) in
    {313}let m1_4: bitstring = (method_4,suitesI_4,G_X_4,C_I_4,EAD_1_4) in
    {314}out(att, m1_4);
    {315}in(att, m2_4: bitstring);
    {316}let (G_Y_4: bitstring,CIPHERTEXT_2_1: bitstring,CT_AUTH_I_4: bitstring) = m2_4 in
    {317}let mess_1_hash_4: bitstring = hash(m1_4) in
    {318}let TH_2_4: bitstring = hash((G_Y_4,mess_1_hash_4)) in
    {319}let G_YX_1: bitstring = kemdecap(G_Y_4,X_1) in
    {320}let PRK_2e_4: bitstring = hkdfextract(TH_2_4,G_YX_1) in
    {321}let KEYSTREAM_2_4: bitstring = edhoc_kdf(PRK_2e_4,stwo,TH_2_4,plaintext_length) in
    {322}let plaintext_2_4: bitstring = decxor(CIPHERTEXT_2_1,KEYSTREAM_2_4) in
    {323}let (C_R_4: bitstring,=idd_2,SIGNATURE_or_MAC_2_4: bitstring,EAD_2_4: bitstring) = plaintext_2_4 in
    {324}let pkI_6: bitstring = get_kem_auth(ID_CRED_I_4) in
    {325}let SALT_3e2m_4: bitstring = edhoc_kdf(PRK_2e_4,sthree,TH_2_4,hash_length) in
    {326}let PRK_3e2m_4: bitstring = hkdfextract(SALT_3e2m_4,K_AUTH_R_4) in
    {327}event eDerivedIShared(pkI_6,G_YX_1);
    {328}let MAC_2_4: bitstring = edhoc_kdf(PRK_3e2m_4,sfour,(idd_2,TH_2_4,pkR_4,EAD_2_4),hash_length) in
    {329}if (SIGNATURE_or_MAC_2_4 = MAC_2_4) then
    {330}event eCheckedMAC2(ID_CRED_I_4,MAC_2_4);
    {331}let TH_3_4: bitstring = hash((TH_2_4,(plaintext_2_4,pkR_4))) in
    {332}event eTHIShared(pkI_6,TH_3_4);
    {333}let K_3_4: bitstring = edhoc_kdf(PRK_3e2m_4,sfive,TH_3_4,key_length) in
    {334}let IV_3_4: bitstring = edhoc_kdf(PRK_3e2m_4,ssix,TH_3_4,iv_length) in
    {335}let SALT_4e3m_4: bitstring = edhoc_kdf(PRK_3e2m_4,sseven,TH_3_4,hash_length) in
    {336}let K_AUTH_I_4: bitstring = kemdecap(CT_AUTH_I_4,sk_kem_authI_2) in
    {337}let PRK_4e3m_4: bitstring = hkdfextract(SALT_4e3m_4,K_AUTH_I_4) in
    {338}let MAC_3_4: bitstring = edhoc_kdf(PRK_4e3m_4,seight,(ID_CRED_I_4,TH_3_4,pkI_6,EAD_3_4),hash_length) in
    {339}let SIGNATURE_or_MAC_3_4: bitstring = MAC_3_4 in
    {340}let plaintext_3_4: bitstring = (ID_CRED_I_4,(SIGNATURE_or_MAC_3_4,EAD_3_4)) in
    {341}let m3_1: bitstring = aeadenc(plaintext_3_4,srep,K_3_4,IV_3_4) in
    {342}let TH_4_4: bitstring = hash((TH_3_4,(plaintext_3_4,pkI_6))) in
    {343}let PRK_out_4: bitstring = edhoc_kdf(PRK_4e3m_4,snine,TH_4_4,hash_length) in
    {344}event eAcceptI(cid_4,method_four,pkI_6,pkR_4,PRK_3e2m_4,PRK_4e3m_4,PRK_out_4,X_1,G_Y_4);
    {345}event eSecretsI(cid_4,method_four,pkI_6,pkR_4,PRK_2e_4,PRK_3e2m_4,PRK_4e3m_4,PRK_out_4,KEYSTREAM_2_4,K_3_4,IV_3_4,X_1,G_Y_4);
    {346}event eAcceptIData(PRK_out_4,method_four,pkI_6,pkR_4,X_1,G_Y_4,(TH_1_4,TH_2_4,(TH_3_4,(TH_4_4,(suitesI_4,(EAD_1_4,(EAD_2_4,(EAD_3_4,(m1_4,(plaintext_1_4,plaintext_2_4,plaintext_3_4))))))))));
    (
        {347}out(att, m3_1)
    ) | (
        {348}event eLeakSessionKey(PRK_out_4);
        {349}out(att, PRK_out_4)
    )
) | (
    {350}phase 1;
    {351}event eCompromise(kempk(sk_auth_kem_1));
    {352}event eCompromise(kempk(sk_auth_kem_2));
    {353}out(att, sk_auth_kem_1);
    {354}out(att, sk_auth_kem_2)
)

-- Observational equivalence in biprocess 1 (that is, biprocess 0, with let moved downwards):
{1}!
{2}new computerId_1: bitstring;
{3}new sk_1: bitstring;
{4}new sk_auth_kem_1: bitstring;
{5}new ltdh_1: bitstring;
{6}let idd_1: bitstring = id(pk(sk_1),ltdh_1,kempk(sk_auth_kem_1)) in
{7}out(att, (idd_1,(pk(sk_1),ltdh_1,kempk(sk_auth_kem_1))));
{8}event eShareLT(ltdh_1);
{9}event eHonest(pk(sk_1));
{10}event eHonest(kempk(sk_auth_kem_1));
{11}new sk_2: bitstring;
{12}new sk_auth_kem_2: bitstring;
{13}new ltdh_2: bitstring;
{14}new computerId_2: bitstring;
{15}let idd_2: bitstring = id(pk(sk_2),ltdh_2,kempk(sk_auth_kem_2)) in
{16}out(att, (idd_2,(pk(sk_2),ltdh_2,kempk(sk_auth_kem_2))));
{17}event eShareLT(ltdh_2);
{18}event eHonest(pk(sk_2));
{19}event eHonest(kempk(sk_auth_kem_2));
(
    {20}!
    {21}in(att, cred_2: bitstring);
    {26}in(att, (method_2: bitstring,(suitesI_2: bitstring,(C_I_2: bitstring,EAD_1_2: bitstring))));
    {27}event eMethodOk(method_2);
    {28}new X_2: bitstring;
    {29}new random_authR: bitstring;
    {30}new EAD_3_2: bitstring;
    {31}event eShare(X_2);
    {25}let sk_kem_authI: bitstring = sk_auth_kem_1 in
    {33}let KEM_CRED_I_2: bitstring = kempk(sk_kem_authI) in
    {23}let skI_2: bitstring = sk_1 in
    {32}let CRED_I_2: bitstring = pk(skI_2) in
    {24}let I_2: bitstring = ltdh_1 in
    {34}let ID_CRED_I_2: bitstring = id(CRED_I_2,I_2,KEM_CRED_I_2) in
    {35}if (ID_CRED_I_2 ≠ check_cred(cred_2)) then
    {36}if (method_2 = method_four) then
    {37}let pkR_2: bitstring = get_kem_auth(cred_2) in
    {42}let G_X_2: bitstring = kempk(X_2) in
    {48}let m1_2: bitstring = (method_2,suitesI_2,G_X_2,C_I_2,EAD_1_2) in
    {49}out(att, m1_2);
    {50}in(att, m2_2: bitstring);
    {51}let (G_Y_2: bitstring,CIPHERTEXT_2_2: bitstring,CT_AUTH_I_2: bitstring) = m2_2 in
    {54}let G_YX_2: bitstring = kemdecap(G_Y_2,X_2) in
    {52}let mess_1_hash_2: bitstring = hash(m1_2) in
    {53}let TH_2_2: bitstring = hash((G_Y_2,mess_1_hash_2)) in
    {55}let PRK_2e_2: bitstring = hkdfextract(TH_2_2,G_YX_2) in
    {56}let KEYSTREAM_2_2: bitstring = edhoc_kdf(PRK_2e_2,stwo,TH_2_2,plaintext_length) in
    {57}let plaintext_2_2: bitstring = decxor(CIPHERTEXT_2_2,KEYSTREAM_2_2) in
    {58}let (C_R_2: bitstring,=cred_2,SIGNATURE_or_MAC_2_2: bitstring,EAD_2_2: bitstring) = plaintext_2_2 in
    {59}let pkI_2: bitstring = get_kem_auth(ID_CRED_I_2) in
    {62}event eDerivedIShared(pkI_2,G_YX_2);
    {60}let SALT_3e2m_2: bitstring = edhoc_kdf(PRK_2e_2,sthree,TH_2_2,hash_length) in
    {38}let encap_auth_R_2: bitstring = kemencap(random_authR,pkR_2) in
    {39}let K_AUTH_R_2: bitstring = kemkey(encap_auth_R_2) in
    {61}let PRK_3e2m_2: bitstring = hkdfextract(SALT_3e2m_2,K_AUTH_R_2) in
    {63}let MAC_2_2: bitstring = edhoc_kdf(PRK_3e2m_2,sfour,(cred_2,TH_2_2,pkR_2,EAD_2_2),hash_length) in
    {64}if (SIGNATURE_or_MAC_2_2 = MAC_2_2) then
    {65}event eCheckedMAC2(ID_CRED_I_2,MAC_2_2);
    {66}let TH_3_2: bitstring = hash((TH_2_2,(plaintext_2_2,pkR_2))) in
    {67}event eTHIShared(pkI_2,TH_3_2);
    {71}let K_AUTH_I_2: bitstring = kemdecap(CT_AUTH_I_2,sk_kem_authI) in
    {70}let SALT_4e3m_2: bitstring = edhoc_kdf(PRK_3e2m_2,sseven,TH_3_2,hash_length) in
    {72}let PRK_4e3m_2: bitstring = hkdfextract(SALT_4e3m_2,K_AUTH_I_2) in
    {73}let MAC_3_2: bitstring = edhoc_kdf(PRK_4e3m_2,seight,(ID_CRED_I_2,TH_3_2,pkI_2,EAD_3_2),hash_length) in
    {74}let SIGNATURE_or_MAC_3_2: bitstring = MAC_3_2 in
    {75}let plaintext_3_2: bitstring = (ID_CRED_I_2,(SIGNATURE_or_MAC_3_2,EAD_3_2)) in
    {77}let TH_4_2: bitstring = hash((TH_3_2,(plaintext_3_2,pkI_2))) in
    {78}let PRK_out_2: bitstring = edhoc_kdf(PRK_4e3m_2,snine,TH_4_2,hash_length) in
    {22}let cid_2: bitstring = computerId_1 in
    {79}event eAcceptI(cid_2,method_four,pkI_2,pkR_2,PRK_3e2m_2,PRK_4e3m_2,PRK_out_2,X_2,G_Y_2);
    {69}let IV_3_2: bitstring = edhoc_kdf(PRK_3e2m_2,ssix,TH_3_2,iv_length) in
    {68}let K_3_2: bitstring = edhoc_kdf(PRK_3e2m_2,sfive,TH_3_2,key_length) in
    {80}event eSecretsI(cid_2,method_four,pkI_2,pkR_2,PRK_2e_2,PRK_3e2m_2,PRK_4e3m_2,PRK_out_2,KEYSTREAM_2_2,K_3_2,IV_3_2,X_2,G_Y_2);
    {40}let CT_AUTH_R_2: bitstring = kemcipher(encap_auth_R_2) in
    {43}let TH_1_2: bitstring = hash((G_X_2,CT_AUTH_R_2)) in
    {41}let plaintext_1_2: bitstring = ID_CRED_I_2 in
    {81}event eAcceptIData(PRK_out_2,method_four,pkI_2,pkR_2,X_2,G_Y_2,(TH_1_2,TH_2_2,(TH_3_2,(TH_4_2,(suitesI_2,(EAD_1_2,(EAD_2_2,(EAD_3_2,(m1_2,(plaintext_1_2,plaintext_2_2,plaintext_3_2))))))))));
    (
        {76}let m3_2: bitstring = aeadenc(plaintext_3_2,srep,K_3_2,IV_3_2) in
        {82}out(att, m3_2)
    ) | (
        {83}event eLeakSessionKey(PRK_out_2);
        {84}out(att, PRK_out_2)
    )
) | (
    {85}!
    {86}in(att, cred_3: bitstring);
    {91}in(att, (method: bitstring,(suitesI: bitstring,(C_I: bitstring,EAD_1: bitstring))));
    {92}event eMethodOk(method);
    {93}new X: bitstring;
    {94}new random_authR_1: bitstring;
    {95}new EAD_3: bitstring;
    {96}event eShare(X);
    {90}let sk_kem_authI_1: bitstring = sk_auth_kem_2 in
    {98}let KEM_CRED_I: bitstring = kempk(sk_kem_authI_1) in
    {88}let skI: bitstring = sk_2 in
    {97}let CRED_I: bitstring = pk(skI) in
    {89}let I_1: bitstring = ltdh_2 in
    {99}let ID_CRED_I: bitstring = id(CRED_I,I_1,KEM_CRED_I) in
    {100}if (ID_CRED_I ≠ check_cred(cred_3)) then
    {101}if (method = method_four) then
    {102}let pkR: bitstring = get_kem_auth(cred_3) in
    {107}let G_X: bitstring = kempk(X) in
    {113}let m1: bitstring = (method,suitesI,G_X,C_I,EAD_1) in
    {114}out(att, m1);
    {115}in(att, m2: bitstring);
    {116}let (G_Y: bitstring,CIPHERTEXT_2: bitstring,CT_AUTH_I: bitstring) = m2 in
    {119}let G_YX: bitstring = kemdecap(G_Y,X) in
    {117}let mess_1_hash: bitstring = hash(m1) in
    {118}let TH_2: bitstring = hash((G_Y,mess_1_hash)) in
    {120}let PRK_2e: bitstring = hkdfextract(TH_2,G_YX) in
    {121}let KEYSTREAM_2: bitstring = edhoc_kdf(PRK_2e,stwo,TH_2,plaintext_length) in
    {122}let plaintext_2: bitstring = decxor(CIPHERTEXT_2,KEYSTREAM_2) in
    {123}let (C_R: bitstring,=cred_3,SIGNATURE_or_MAC_2: bitstring,EAD_2: bitstring) = plaintext_2 in
    {124}let pkI: bitstring = get_kem_auth(ID_CRED_I) in
    {127}event eDerivedIShared(pkI,G_YX);
    {125}let SALT_3e2m: bitstring = edhoc_kdf(PRK_2e,sthree,TH_2,hash_length) in
    {103}let encap_auth_R: bitstring = kemencap(random_authR_1,pkR) in
    {104}let K_AUTH_R: bitstring = kemkey(encap_auth_R) in
    {126}let PRK_3e2m: bitstring = hkdfextract(SALT_3e2m,K_AUTH_R) in
    {128}let MAC_2: bitstring = edhoc_kdf(PRK_3e2m,sfour,(cred_3,TH_2,pkR,EAD_2),hash_length) in
    {129}if (SIGNATURE_or_MAC_2 = MAC_2) then
    {130}event eCheckedMAC2(ID_CRED_I,MAC_2);
    {131}let TH_3: bitstring = hash((TH_2,(plaintext_2,pkR))) in
    {132}event eTHIShared(pkI,TH_3);
    {136}let K_AUTH_I: bitstring = kemdecap(CT_AUTH_I,sk_kem_authI_1) in
    {135}let SALT_4e3m: bitstring = edhoc_kdf(PRK_3e2m,sseven,TH_3,hash_length) in
    {137}let PRK_4e3m: bitstring = hkdfextract(SALT_4e3m,K_AUTH_I) in
    {138}let MAC_3: bitstring = edhoc_kdf(PRK_4e3m,seight,(ID_CRED_I,TH_3,pkI,EAD_3),hash_length) in
    {139}let SIGNATURE_or_MAC_3: bitstring = MAC_3 in
    {140}let plaintext_3: bitstring = (ID_CRED_I,(SIGNATURE_or_MAC_3,EAD_3)) in
    {142}let TH_4: bitstring = hash((TH_3,(plaintext_3,pkI))) in
    {143}let PRK_out: bitstring = edhoc_kdf(PRK_4e3m,snine,TH_4,hash_length) in
    {87}let cid: bitstring = computerId_2 in
    {144}event eAcceptI(cid,method_four,pkI,pkR,PRK_3e2m,PRK_4e3m,PRK_out,X,G_Y);
    {134}let IV_3: bitstring = edhoc_kdf(PRK_3e2m,ssix,TH_3,iv_length) in
    {133}let K_3: bitstring = edhoc_kdf(PRK_3e2m,sfive,TH_3,key_length) in
    {145}event eSecretsI(cid,method_four,pkI,pkR,PRK_2e,PRK_3e2m,PRK_4e3m,PRK_out,KEYSTREAM_2,K_3,IV_3,X,G_Y);
    {105}let CT_AUTH_R: bitstring = kemcipher(encap_auth_R) in
    {108}let TH_1: bitstring = hash((G_X,CT_AUTH_R)) in
    {106}let plaintext_1: bitstring = ID_CRED_I in
    {146}event eAcceptIData(PRK_out,method_four,pkI,pkR,X,G_Y,(TH_1,TH_2,(TH_3,(TH_4,(suitesI,(EAD_1,(EAD_2,(EAD_3,(m1,(plaintext_1,plaintext_2,plaintext_3))))))))));
    (
        {141}let m3: bitstring = aeadenc(plaintext_3,srep,K_3,IV_3) in
        {147}out(att, m3)
    ) | (
        {148}event eLeakSessionKey(PRK_out);
        {149}out(att, PRK_out)
    )
) | (
    {150}!
    {155}in(att, (C_R_1: bitstring,(EAD_2_1: bitstring,suitesR_2: bitstring)));
    {156}in(att, m1_1: bitstring);
    {157}let (method_1: bitstring,suitesI_1: bitstring,G_X_1: bitstring,C_I_1: bitstring,CT_AUTH_R_1: bitstring,CIPHERTEXT_1_1: bitstring,EAD_1_1: bitstring) = m1_1 in
    {158}event eMethodOk(method_1);
    {159}new Y_2: bitstring;
    {160}event eShare(Y_2);
    {168}if (method_1 = method_four) then
    {170}let TH_1_1: bitstring = hash((G_X_1,CT_AUTH_R_1)) in
    {154}let sk_kem_authR_2: bitstring = sk_auth_kem_1 in
    {169}let K_AUTH_R_1: bitstring = kemdecap(CT_AUTH_R_1,sk_kem_authR_2) in
    {171}let PRK_1e_1: bitstring = hkdfextract(TH_1_1,K_AUTH_R_1) in
    {173}let IV_1_1: bitstring = edhoc_kdf(PRK_1e_1,sone,TH_1_1,iv_length) in
    {172}let K_1_1: bitstring = edhoc_kdf(PRK_1e_1,szero,TH_1_1,key_length) in
    {174}let plaintext_1_1: bitstring = aeaddec(CIPHERTEXT_1_1,K_1_1,IV_1_1) in
    {175}let ID_CRED_I_1: bitstring = plaintext_1_1 in
    {166}let KEM_CRED_R_2: bitstring = kempk(sk_kem_authR_2) in
    {152}let skR_2: bitstring = sk_1 in
    {165}let CRED_R_2: bitstring = pk(skR_2) in
    {153}let R_2: bitstring = ltdh_1 in
    {161}let G_R_2: bitstring = R_2 in
    {167}let ID_CRED_R_2: bitstring = id(CRED_R_2,G_R_2,KEM_CRED_R_2) in
    {176}if (ID_CRED_R_2 ≠ check_cred(ID_CRED_I_1)) then
    {180}let pkR_1: bitstring = get_kem_auth(ID_CRED_R_2) in
    {181}let pkI_1: bitstring = get_kem_auth(ID_CRED_I_1) in
    {177}let mess_1_hash_1: bitstring = hash(m1_1) in
    {162}let encapsulation: bitstring = kemencap(Y_2,G_X_1) in
    {163}let G_Y_1: bitstring = kemcipher(encapsulation) in
    {178}let TH_2_1: bitstring = hash((G_Y_1,mess_1_hash_1)) in
    {164}let G_XY_2: bitstring = kemkey(encapsulation) in
    {179}let PRK_2e_1: bitstring = hkdfextract(TH_2_1,G_XY_2) in
    {183}let SALT_3e2m_1: bitstring = edhoc_kdf(PRK_2e_1,sthree,TH_2_1,hash_length) in
    {184}let PRK_3e2m_1: bitstring = hkdfextract(SALT_3e2m_1,K_AUTH_R_1) in
    {151}let cid_1: bitstring = computerId_1 in
    {188}event eDerivedR(cid_1,pkR_1,PRK_3e2m_1,Y_2,G_X_1);
    {189}event eTHRShared(pkR_1,TH_2_1);
    {190}event eDerivedRShared(pkR_1,G_XY_2);
    {191}event eDerivedIdR(ID_CRED_R_2,PRK_3e2m_1);
    {192}new encap_auth_random_seed: bitstring;
    {185}let MAC_2_1: bitstring = edhoc_kdf(PRK_3e2m_1,sfour,(ID_CRED_R_2,TH_2_1,pkR_1,EAD_2_1),hash_length) in
    {186}let SIGNATURE_or_MAC_2_1: bitstring = MAC_2_1 in
    {187}let plaintext_2_1: bitstring = (C_R_1,(ID_CRED_R_2,(SIGNATURE_or_MAC_2_1,EAD_2_1))) in
    {197}event eSendRData(method_four,pkR_1,(TH_1_1,TH_2_1,(suitesI_1,(EAD_1_1,(EAD_2_1,(m1_1,plaintext_1_1,plaintext_2_1))))));
    {182}let KEYSTREAM_2_1: bitstring = edhoc_kdf(PRK_2e_1,stwo,TH_2_1,plaintext_length) in
    {196}let m2_1: bitstring = (G_Y_1,encxor(plaintext_2_1,KEYSTREAM_2_1)) in
    {198}out(att, m2_1);
    {199}in(att, CIPHERTEXT_3_2: bitstring);
    {200}let TH_3_1: bitstring = hash((TH_2_1,(plaintext_2_1,pkR_1))) in
    {202}let IV_3_1: bitstring = edhoc_kdf(PRK_3e2m_1,ssix,TH_3_1,iv_length) in
    {201}let K_3_1: bitstring = edhoc_kdf(PRK_3e2m_1,sfive,TH_3_1,key_length) in
    {205}let plaintext_3_1: bitstring = aeaddec(CIPHERTEXT_3_2,K_3_1,IV_3_1) in
    {206}let (=ID_CRED_I_1,(SIGNATURE_or_MAC_3_1: bitstring,EAD_3_1: bitstring)) = plaintext_3_1 in
    {207}let pkI_3: bitstring = get_kem_auth(ID_CRED_I_1) in
    {203}let SALT_4e3m_1: bitstring = edhoc_kdf(PRK_3e2m_1,sseven,TH_3_1,hash_length) in
    {193}let encap_auth_I_2: bitstring = kemencap(encap_auth_random_seed,pkI_1) in
    {194}let K_AUTH_I_1: bitstring = kemkey(encap_auth_I_2) in
    {204}let PRK_4e3m_1: bitstring = hkdfextract(SALT_4e3m_1,K_AUTH_I_1) in
    {208}let MAC_3_1: bitstring = edhoc_kdf(PRK_4e3m_1,seight,(ID_CRED_I_1,TH_3_1,pkI_3,EAD_3_1),hash_length) in
    {209}if (SIGNATURE_or_MAC_3_1 = MAC_3_1) then
    {210}event eCheckedMAC3(ID_CRED_R_2,MAC_3_1);
    {211}let TH_4_1: bitstring = hash((TH_3_1,(plaintext_3_1,pkI_3))) in
    {212}let PRK_out_1: bitstring = edhoc_kdf(PRK_4e3m_1,snine,TH_4_1,hash_length) in
    {213}event eAcceptR(cid_1,method_four,pkI_3,pkR_1,PRK_3e2m_1,PRK_4e3m_1,PRK_out_1,Y_2,G_X_1);
    {214}event eSecretsR(cid_1,method_four,pkI_3,pkR_1,PRK_2e_1,PRK_3e2m_1,PRK_4e3m_1,PRK_out_1,KEYSTREAM_2_1,K_3_1,IV_3_1,Y_2,G_X_1);
    (
        {215}event eAcceptRData(PRK_out_1,method_four,pkI_3,pkR_1,Y_2,G_X_1,(TH_1_1,TH_2_1,(TH_3_1,(TH_4_1,(suitesI_1,(EAD_1_1,(EAD_2_1,(EAD_3_1,(m1_1,(plaintext_1_1,plaintext_2_1,plaintext_3_1))))))))))
    ) | (
        {216}event eLeakSessionKey(PRK_out_1);
        {217}out(att, PRK_out_1)
    )
) | (
    {218}!
    {223}in(att, (C_R_3: bitstring,(EAD_2_3: bitstring,suitesR: bitstring)));
    {224}in(att, m1_3: bitstring);
    {225}let (method_3: bitstring,suitesI_3: bitstring,G_X_3: bitstring,C_I_3: bitstring,CT_AUTH_R_3: bitstring,CIPHERTEXT_1_3: bitstring,EAD_1_3: bitstring) = m1_3 in
    {226}event eMethodOk(method_3);
    {227}new Y: bitstring;
    {228}event eShare(Y);
    {236}if (method_3 = method_four) then
    {238}let TH_1_3: bitstring = hash((G_X_3,CT_AUTH_R_3)) in
    {222}let sk_kem_authR: bitstring = sk_auth_kem_2 in
    {237}let K_AUTH_R_3: bitstring = kemdecap(CT_AUTH_R_3,sk_kem_authR) in
    {239}let PRK_1e_3: bitstring = hkdfextract(TH_1_3,K_AUTH_R_3) in
    {241}let IV_1_3: bitstring = edhoc_kdf(PRK_1e_3,sone,TH_1_3,iv_length) in
    {240}let K_1_3: bitstring = edhoc_kdf(PRK_1e_3,szero,TH_1_3,key_length) in
    {242}let plaintext_1_3: bitstring = aeaddec(CIPHERTEXT_1_3,K_1_3,IV_1_3) in
    {243}let ID_CRED_I_3: bitstring = plaintext_1_3 in
    {234}let KEM_CRED_R: bitstring = kempk(sk_kem_authR) in
    {220}let skR: bitstring = sk_2 in
    {233}let CRED_R: bitstring = pk(skR) in
    {221}let R_1: bitstring = ltdh_2 in
    {229}let G_R: bitstring = R_1 in
    {235}let ID_CRED_R: bitstring = id(CRED_R,G_R,KEM_CRED_R) in
    {244}if (ID_CRED_R ≠ check_cred(ID_CRED_I_3)) then
    {248}let pkR_3: bitstring = get_kem_auth(ID_CRED_R) in
    {249}let pkI_4: bitstring = get_kem_auth(ID_CRED_I_3) in
    {245}let mess_1_hash_3: bitstring = hash(m1_3) in
    {230}let encapsulation_1: bitstring = kemencap(Y,G_X_3) in
    {231}let G_Y_3: bitstring = kemcipher(encapsulation_1) in
    {246}let TH_2_3: bitstring = hash((G_Y_3,mess_1_hash_3)) in
    {232}let G_XY: bitstring = kemkey(encapsulation_1) in
    {247}let PRK_2e_3: bitstring = hkdfextract(TH_2_3,G_XY) in
    {251}let SALT_3e2m_3: bitstring = edhoc_kdf(PRK_2e_3,sthree,TH_2_3,hash_length) in
    {252}let PRK_3e2m_3: bitstring = hkdfextract(SALT_3e2m_3,K_AUTH_R_3) in
    {219}let cid_3: bitstring = computerId_2 in
    {256}event eDerivedR(cid_3,pkR_3,PRK_3e2m_3,Y,G_X_3);
    {257}event eTHRShared(pkR_3,TH_2_3);
    {258}event eDerivedRShared(pkR_3,G_XY);
    {259}event eDerivedIdR(ID_CRED_R,PRK_3e2m_3);
    {260}new encap_auth_random_seed_1: bitstring;
    {253}let MAC_2_3: bitstring = edhoc_kdf(PRK_3e2m_3,sfour,(ID_CRED_R,TH_2_3,pkR_3,EAD_2_3),hash_length) in
    {254}let SIGNATURE_or_MAC_2_3: bitstring = MAC_2_3 in
    {255}let plaintext_2_3: bitstring = (C_R_3,(ID_CRED_R,(SIGNATURE_or_MAC_2_3,EAD_2_3))) in
    {265}event eSendRData(method_four,pkR_3,(TH_1_3,TH_2_3,(suitesI_3,(EAD_1_3,(EAD_2_3,(m1_3,plaintext_1_3,plaintext_2_3))))));
    {250}let KEYSTREAM_2_3: bitstring = edhoc_kdf(PRK_2e_3,stwo,TH_2_3,plaintext_length) in
    {264}let m2_3: bitstring = (G_Y_3,encxor(plaintext_2_3,KEYSTREAM_2_3)) in
    {266}out(att, m2_3);
    {267}in(att, CIPHERTEXT_3: bitstring);
    {268}let TH_3_3: bitstring = hash((TH_2_3,(plaintext_2_3,pkR_3))) in
    {270}let IV_3_3: bitstring = edhoc_kdf(PRK_3e2m_3,ssix,TH_3_3,iv_length) in
    {269}let K_3_3: bitstring = edhoc_kdf(PRK_3e2m_3,sfive,TH_3_3,key_length) in
    {273}let plaintext_3_3: bitstring = aeaddec(CIPHERTEXT_3,K_3_3,IV_3_3) in
    {274}let (=ID_CRED_I_3,(SIGNATURE_or_MAC_3_3: bitstring,EAD_3_3: bitstring)) = plaintext_3_3 in
    {275}let pkI_5: bitstring = get_kem_auth(ID_CRED_I_3) in
    {271}let SALT_4e3m_3: bitstring = edhoc_kdf(PRK_3e2m_3,sseven,TH_3_3,hash_length) in
    {261}let encap_auth_I: bitstring = kemencap(encap_auth_random_seed_1,pkI_4) in
    {262}let K_AUTH_I_3: bitstring = kemkey(encap_auth_I) in
    {272}let PRK_4e3m_3: bitstring = hkdfextract(SALT_4e3m_3,K_AUTH_I_3) in
    {276}let MAC_3_3: bitstring = edhoc_kdf(PRK_4e3m_3,seight,(ID_CRED_I_3,TH_3_3,pkI_5,EAD_3_3),hash_length) in
    {277}if (SIGNATURE_or_MAC_3_3 = MAC_3_3) then
    {278}event eCheckedMAC3(ID_CRED_R,MAC_3_3);
    {279}let TH_4_3: bitstring = hash((TH_3_3,(plaintext_3_3,pkI_5))) in
    {280}let PRK_out_3: bitstring = edhoc_kdf(PRK_4e3m_3,snine,TH_4_3,hash_length) in
    {281}event eAcceptR(cid_3,method_four,pkI_5,pkR_3,PRK_3e2m_3,PRK_4e3m_3,PRK_out_3,Y,G_X_3);
    {282}event eSecretsR(cid_3,method_four,pkI_5,pkR_3,PRK_2e_3,PRK_3e2m_3,PRK_4e3m_3,PRK_out_3,KEYSTREAM_2_3,K_3_3,IV_3_3,Y,G_X_3);
    (
        {283}event eAcceptRData(PRK_out_3,method_four,pkI_5,pkR_3,Y,G_X_3,(TH_1_3,TH_2_3,(TH_3_3,(TH_4_3,(suitesI_3,(EAD_1_3,(EAD_2_3,(EAD_3_3,(m1_3,(plaintext_1_3,plaintext_2_3,plaintext_3_3))))))))))
    ) | (
        {284}event eLeakSessionKey(PRK_out_3);
        {285}out(att, PRK_out_3)
    )
) | (
    {286}!
    {291}in(att, (method_4: bitstring,(suitesI_4: bitstring,(C_I_4: bitstring,EAD_1_4: bitstring))));
    {292}event eMethodOk(method_4);
    {293}new X_1: bitstring;
    {294}new random_authR_2: bitstring;
    {295}new EAD_3_4: bitstring;
    {296}event eShare(X_1);
    {290}let sk_kem_authI_2: bitstring = choice[sk_auth_kem_1,sk_auth_kem_2] in
    {298}let KEM_CRED_I_1: bitstring = kempk(sk_kem_authI_2) in
    {288}let skI_1: bitstring = choice[sk_1,sk_2] in
    {297}let CRED_I_1: bitstring = pk(skI_1) in
    {289}let I_3: bitstring = choice[ltdh_1,ltdh_2] in
    {299}let ID_CRED_I_4: bitstring = id(CRED_I_1,I_3,KEM_CRED_I_1) in
    {300}if (ID_CRED_I_4 ≠ check_cred(idd_2)) then
    {301}if (method_4 = method_four) then
    {302}let pkR_4: bitstring = get_kem_auth(idd_2) in
    {307}let G_X_4: bitstring = kempk(X_1) in
    {313}let m1_4: bitstring = (method_4,suitesI_4,G_X_4,C_I_4,EAD_1_4) in
    {314}out(att, m1_4);
    {315}in(att, m2_4: bitstring);
    {316}let (G_Y_4: bitstring,CIPHERTEXT_2_1: bitstring,CT_AUTH_I_4: bitstring) = m2_4 in
    {319}let G_YX_1: bitstring = kemdecap(G_Y_4,X_1) in
    {317}let mess_1_hash_4: bitstring = hash(m1_4) in
    {318}let TH_2_4: bitstring = hash((G_Y_4,mess_1_hash_4)) in
    {320}let PRK_2e_4: bitstring = hkdfextract(TH_2_4,G_YX_1) in
    {321}let KEYSTREAM_2_4: bitstring = edhoc_kdf(PRK_2e_4,stwo,TH_2_4,plaintext_length) in
    {322}let plaintext_2_4: bitstring = decxor(CIPHERTEXT_2_1,KEYSTREAM_2_4) in
    {323}let (C_R_4: bitstring,=idd_2,SIGNATURE_or_MAC_2_4: bitstring,EAD_2_4: bitstring) = plaintext_2_4 in
    {324}let pkI_6: bitstring = get_kem_auth(ID_CRED_I_4) in
    {327}event eDerivedIShared(pkI_6,G_YX_1);
    {325}let SALT_3e2m_4: bitstring = edhoc_kdf(PRK_2e_4,sthree,TH_2_4,hash_length) in
    {303}let encap_auth_R_1: bitstring = kemencap(random_authR_2,pkR_4) in
    {304}let K_AUTH_R_4: bitstring = kemkey(encap_auth_R_1) in
    {326}let PRK_3e2m_4: bitstring = hkdfextract(SALT_3e2m_4,K_AUTH_R_4) in
    {328}let MAC_2_4: bitstring = edhoc_kdf(PRK_3e2m_4,sfour,(idd_2,TH_2_4,pkR_4,EAD_2_4),hash_length) in
    {329}if (SIGNATURE_or_MAC_2_4 = MAC_2_4) then
    {330}event eCheckedMAC2(ID_CRED_I_4,MAC_2_4);
    {331}let TH_3_4: bitstring = hash((TH_2_4,(plaintext_2_4,pkR_4))) in
    {332}event eTHIShared(pkI_6,TH_3_4);
    {336}let K_AUTH_I_4: bitstring = kemdecap(CT_AUTH_I_4,sk_kem_authI_2) in
    {335}let SALT_4e3m_4: bitstring = edhoc_kdf(PRK_3e2m_4,sseven,TH_3_4,hash_length) in
    {337}let PRK_4e3m_4: bitstring = hkdfextract(SALT_4e3m_4,K_AUTH_I_4) in
    {338}let MAC_3_4: bitstring = edhoc_kdf(PRK_4e3m_4,seight,(ID_CRED_I_4,TH_3_4,pkI_6,EAD_3_4),hash_length) in
    {339}let SIGNATURE_or_MAC_3_4: bitstring = MAC_3_4 in
    {340}let plaintext_3_4: bitstring = (ID_CRED_I_4,(SIGNATURE_or_MAC_3_4,EAD_3_4)) in
    {342}let TH_4_4: bitstring = hash((TH_3_4,(plaintext_3_4,pkI_6))) in
    {343}let PRK_out_4: bitstring = edhoc_kdf(PRK_4e3m_4,snine,TH_4_4,hash_length) in
    {287}let cid_4: bitstring = choice[computerId_1,computerId_2] in
    {344}event eAcceptI(cid_4,method_four,pkI_6,pkR_4,PRK_3e2m_4,PRK_4e3m_4,PRK_out_4,X_1,G_Y_4);
    {334}let IV_3_4: bitstring = edhoc_kdf(PRK_3e2m_4,ssix,TH_3_4,iv_length) in
    {333}let K_3_4: bitstring = edhoc_kdf(PRK_3e2m_4,sfive,TH_3_4,key_length) in
    {345}event eSecretsI(cid_4,method_four,pkI_6,pkR_4,PRK_2e_4,PRK_3e2m_4,PRK_4e3m_4,PRK_out_4,KEYSTREAM_2_4,K_3_4,IV_3_4,X_1,G_Y_4);
    {305}let CT_AUTH_R_4: bitstring = kemcipher(encap_auth_R_1) in
    {308}let TH_1_4: bitstring = hash((G_X_4,CT_AUTH_R_4)) in
    {306}let plaintext_1_4: bitstring = ID_CRED_I_4 in
    {346}event eAcceptIData(PRK_out_4,method_four,pkI_6,pkR_4,X_1,G_Y_4,(TH_1_4,TH_2_4,(TH_3_4,(TH_4_4,(suitesI_4,(EAD_1_4,(EAD_2_4,(EAD_3_4,(m1_4,(plaintext_1_4,plaintext_2_4,plaintext_3_4))))))))));
    (
        {341}let m3_1: bitstring = aeadenc(plaintext_3_4,srep,K_3_4,IV_3_4) in
        {347}out(att, m3_1)
    ) | (
        {348}event eLeakSessionKey(PRK_out_4);
        {349}out(att, PRK_out_4)
    )
) | (
    {350}phase 1;
    {351}event eCompromise(kempk(sk_auth_kem_1));
    {352}event eCompromise(kempk(sk_auth_kem_2));
    {353}out(att, sk_auth_kem_1);
    {354}out(att, sk_auth_kem_2)
)

Translating the process into Horn clauses...
Termination warning: v ≠ v_1 && attacker2_p1(v_2,v) && attacker2_p1(v_2,v_1) -> bad
Selecting 0
Termination warning: v ≠ v_1 && attacker2_p1(v,v_2) && attacker2_p1(v_1,v_2) -> bad
Selecting 0
Completing...
200 rules inserted. Base: 200 rules (95 with conclusion selected). Queue: 346 rules.
Termination warning: v ≠ v_1 && attacker2_p1(v_2,v) && attacker2_p1(v_2,v_1) -> bad
Selecting 0
Termination warning: v ≠ v_1 && attacker2_p1(v,v_2) && attacker2_p1(v_1,v_2) -> bad
Selecting 0
400 rules inserted. Base: 400 rules (120 with conclusion selected). Queue: 329 rules.
Termination warning: v ≠ v_1 && attacker2(v_2,v) && attacker2_p1(v_2,v_1) -> bad
Selecting 0
Termination warning: v ≠ v_1 && attacker2(v,v_2) && attacker2_p1(v_1,v_2) -> bad
Selecting 0
600 rules inserted. Base: 600 rules (131 with conclusion selected). Queue: 361 rules.
800 rules inserted. Base: 800 rules (133 with conclusion selected). Queue: 363 rules.
Termination warning: v ≠ v_1 && attacker2(v_2,v) && attacker2(v_2,v_1) -> bad
Selecting 0
Termination warning: v ≠ v_1 && attacker2(v,v_2) && attacker2(v_1,v_2) -> bad
Selecting 0
1000 rules inserted. Base: 982 rules (133 with conclusion selected). Queue: 327 rules.
1200 rules inserted. Base: 1134 rules (133 with conclusion selected). Queue: 320 rules.
1400 rules inserted. Base: 1334 rules (133 with conclusion selected). Queue: 276 rules.
1600 rules inserted. Base: 1508 rules (134 with conclusion selected). Queue: 287 rules.
1800 rules inserted. Base: 1600 rules (134 with conclusion selected). Queue: 289 rules.
2000 rules inserted. Base: 1793 rules (136 with conclusion selected). Queue: 276 rules.
2200 rules inserted. Base: 1988 rules (136 with conclusion selected). Queue: 244 rules.
2400 rules inserted. Base: 2178 rules (136 with conclusion selected). Queue: 228 rules.
2600 rules inserted. Base: 2354 rules (136 with conclusion selected). Queue: 210 rules.
2800 rules inserted. Base: 2550 rules (136 with conclusion selected). Queue: 208 rules.
3000 rules inserted. Base: 2734 rules (136 with conclusion selected). Queue: 170 rules.
3200 rules inserted. Base: 2902 rules (140 with conclusion selected). Queue: 288 rules.
3400 rules inserted. Base: 3082 rules (140 with conclusion selected). Queue: 289 rules.
3600 rules inserted. Base: 3262 rules (142 with conclusion selected). Queue: 308 rules.
3800 rules inserted. Base: 3446 rules (146 with conclusion selected). Queue: 364 rules.
4000 rules inserted. Base: 3588 rules (148 with conclusion selected). Queue: 354 rules.
4200 rules inserted. Base: 3752 rules (148 with conclusion selected). Queue: 287 rules.
4400 rules inserted. Base: 3919 rules (148 with conclusion selected). Queue: 288 rules.
4600 rules inserted. Base: 4107 rules (148 with conclusion selected). Queue: 249 rules.
4800 rules inserted. Base: 4262 rules (148 with conclusion selected). Queue: 235 rules.
5000 rules inserted. Base: 4418 rules (148 with conclusion selected). Queue: 208 rules.
5200 rules inserted. Base: 4597 rules (148 with conclusion selected). Queue: 155 rules.
5400 rules inserted. Base: 4735 rules (148 with conclusion selected). Queue: 220 rules.
5600 rules inserted. Base: 4893 rules (148 with conclusion selected). Queue: 239 rules.
5800 rules inserted. Base: 5053 rules (148 with conclusion selected). Queue: 200 rules.
6000 rules inserted. Base: 5201 rules (148 with conclusion selected). Queue: 214 rules.
6200 rules inserted. Base: 5322 rules (148 with conclusion selected). Queue: 228 rules.
6400 rules inserted. Base: 5450 rules (148 with conclusion selected). Queue: 258 rules.
6600 rules inserted. Base: 5572 rules (148 with conclusion selected). Queue: 317 rules.
6800 rules inserted. Base: 5710 rules (148 with conclusion selected). Queue: 381 rules.
7000 rules inserted. Base: 5815 rules (148 with conclusion selected). Queue: 408 rules.
7200 rules inserted. Base: 5903 rules (148 with conclusion selected). Queue: 428 rules.
7400 rules inserted. Base: 5950 rules (148 with conclusion selected). Queue: 479 rules.
7600 rules inserted. Base: 6016 rules (148 with conclusion selected). Queue: 511 rules.
7800 rules inserted. Base: 6088 rules (149 with conclusion selected). Queue: 511 rules.
8000 rules inserted. Base: 6199 rules (149 with conclusion selected). Queue: 586 rules.
8200 rules inserted. Base: 6258 rules (150 with conclusion selected). Queue: 670 rules.
8400 rules inserted. Base: 6362 rules (155 with conclusion selected). Queue: 793 rules.
8600 rules inserted. Base: 6507 rules (160 with conclusion selected). Queue: 847 rules.
8800 rules inserted. Base: 6622 rules (160 with conclusion selected). Queue: 969 rules.
9000 rules inserted. Base: 6769 rules (162 with conclusion selected). Queue: 1007 rules.
9200 rules inserted. Base: 6857 rules (162 with conclusion selected). Queue: 1046 rules.
9400 rules inserted. Base: 7019 rules (164 with conclusion selected). Queue: 1123 rules.
9600 rules inserted. Base: 7118 rules (164 with conclusion selected). Queue: 1152 rules.
9800 rules inserted. Base: 7276 rules (164 with conclusion selected). Queue: 1207 rules.
10000 rules inserted. Base: 7430 rules (164 with conclusion selected). Queue: 1180 rules.
10200 rules inserted. Base: 7536 rules (164 with conclusion selected). Queue: 1116 rules.
10400 rules inserted. Base: 7711 rules (164 with conclusion selected). Queue: 1067 rules.
10600 rules inserted. Base: 7856 rules (164 with conclusion selected). Queue: 1028 rules.
10800 rules inserted. Base: 7970 rules (164 with conclusion selected). Queue: 960 rules.
11000 rules inserted. Base: 8150 rules (164 with conclusion selected). Queue: 913 rules.
11200 rules inserted. Base: 8295 rules (164 with conclusion selected). Queue: 889 rules.
11400 rules inserted. Base: 8468 rules (164 with conclusion selected). Queue: 808 rules.
11600 rules inserted. Base: 8634 rules (164 with conclusion selected). Queue: 799 rules.
11800 rules inserted. Base: 8789 rules (164 with conclusion selected). Queue: 704 rules.
12000 rules inserted. Base: 8942 rules (164 with conclusion selected). Queue: 784 rules.
12200 rules inserted. Base: 9087 rules (164 with conclusion selected). Queue: 831 rules.
12400 rules inserted. Base: 9218 rules (164 with conclusion selected). Queue: 875 rules.
12600 rules inserted. Base: 9366 rules (164 with conclusion selected). Queue: 951 rules.
12800 rules inserted. Base: 9474 rules (164 with conclusion selected). Queue: 985 rules.
13000 rules inserted. Base: 9597 rules (164 with conclusion selected). Queue: 1023 rules.
13200 rules inserted. Base: 9715 rules (164 with conclusion selected). Queue: 1063 rules.
13400 rules inserted. Base: 9823 rules (164 with conclusion selected). Queue: 1048 rules.
13600 rules inserted. Base: 9959 rules (164 with conclusion selected). Queue: 1053 rules.
13800 rules inserted. Base: 10050 rules (164 with conclusion selected). Queue: 1019 rules.
14000 rules inserted. Base: 10188 rules (164 with conclusion selected). Queue: 1009 rules.
14200 rules inserted. Base: 10294 rules (164 with conclusion selected). Queue: 981 rules.
14400 rules inserted. Base: 10418 rules (164 with conclusion selected). Queue: 937 rules.
14600 rules inserted. Base: 10541 rules (164 with conclusion selected). Queue: 902 rules.
14800 rules inserted. Base: 10674 rules (164 with conclusion selected). Queue: 793 rules.
15000 rules inserted. Base: 10813 rules (164 with conclusion selected). Queue: 780 rules.
15200 rules inserted. Base: 10914 rules (164 with conclusion selected). Queue: 687 rules.
15400 rules inserted. Base: 11040 rules (164 with conclusion selected). Queue: 639 rules.
15600 rules inserted. Base: 11139 rules (164 with conclusion selected). Queue: 540 rules.
15800 rules inserted. Base: 11233 rules (164 with conclusion selected). Queue: 485 rules.
16000 rules inserted. Base: 11323 rules (164 with conclusion selected). Queue: 414 rules.
16200 rules inserted. Base: 11400 rules (164 with conclusion selected). Queue: 336 rules.
16400 rules inserted. Base: 11528 rules (164 with conclusion selected). Queue: 277 rules.
16600 rules inserted. Base: 11656 rules (164 with conclusion selected). Queue: 207 rules.
16800 rules inserted. Base: 11770 rules (164 with conclusion selected). Queue: 153 rules.
17000 rules inserted. Base: 11864 rules (164 with conclusion selected). Queue: 154 rules.
17200 rules inserted. Base: 11957 rules (164 with conclusion selected). Queue: 167 rules.
17400 rules inserted. Base: 11978 rules (164 with conclusion selected). Queue: 385 rules.
17600 rules inserted. Base: 11998 rules (164 with conclusion selected). Queue: 478 rules.
17800 rules inserted. Base: 11961 rules (164 with conclusion selected). Queue: 584 rules.
18000 rules inserted. Base: 11941 rules (164 with conclusion selected). Queue: 715 rules.
18200 rules inserted. Base: 11911 rules (164 with conclusion selected). Queue: 785 rules.
18400 rules inserted. Base: 11910 rules (164 with conclusion selected). Queue: 883 rules.
18600 rules inserted. Base: 11866 rules (164 with conclusion selected). Queue: 971 rules.
18800 rules inserted. Base: 11900 rules (164 with conclusion selected). Queue: 986 rules.
19000 rules inserted. Base: 11923 rules (164 with conclusion selected). Queue: 982 rules.
19200 rules inserted. Base: 11932 rules (164 with conclusion selected). Queue: 1027 rules.
19400 rules inserted. Base: 11991 rules (164 with conclusion selected). Queue: 974 rules.
19600 rules inserted. Base: 12018 rules (164 with conclusion selected). Queue: 971 rules.
19800 rules inserted. Base: 12083 rules (164 with conclusion selected). Queue: 936 rules.
20000 rules inserted. Base: 12159 rules (164 with conclusion selected). Queue: 900 rules.
20200 rules inserted. Base: 12202 rules (164 with conclusion selected). Queue: 886 rules.
20400 rules inserted. Base: 12284 rules (164 with conclusion selected). Queue: 806 rules.
20600 rules inserted. Base: 12342 rules (164 with conclusion selected). Queue: 767 rules.
20800 rules inserted. Base: 12404 rules (164 with conclusion selected). Queue: 725 rules.
21000 rules inserted. Base: 12447 rules (164 with conclusion selected). Queue: 691 rules.
21200 rules inserted. Base: 12534 rules (164 with conclusion selected). Queue: 640 rules.
21400 rules inserted. Base: 12608 rules (164 with conclusion selected). Queue: 600 rules.
21600 rules inserted. Base: 12691 rules (164 with conclusion selected). Queue: 543 rules.
21800 rules inserted. Base: 12771 rules (164 with conclusion selected). Queue: 532 rules.
22000 rules inserted. Base: 12835 rules (164 with conclusion selected). Queue: 543 rules.
22200 rules inserted. Base: 12927 rules (164 with conclusion selected). Queue: 527 rules.
22400 rules inserted. Base: 13018 rules (164 with conclusion selected). Queue: 549 rules.
22600 rules inserted. Base: 13061 rules (164 with conclusion selected). Queue: 548 rules.
22800 rules inserted. Base: 13073 rules (164 with conclusion selected). Queue: 540 rules.
23000 rules inserted. Base: 13099 rules (164 with conclusion selected). Queue: 481 rules.
23200 rules inserted. Base: 13120 rules (164 with conclusion selected). Queue: 419 rules.
23400 rules inserted. Base: 13225 rules (164 with conclusion selected). Queue: 326 rules.
23600 rules inserted. Base: 13197 rules (164 with conclusion selected). Queue: 205 rules.
23800 rules inserted. Base: 13126 rules (164 with conclusion selected). Queue: 21 rules.
RESULT Observational equivalence is true.

--------------------------------------------------------------
Verification summary:

Observational equivalence is true.

--------------------------------------------------------------

// 3 minutes