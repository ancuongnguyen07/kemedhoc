File "lake-edhoc-KEM-KEM_processed.pv", line 390, characters 19-23:
Warning: identifier pkI_2 rebound.
Linear part: No equation.
Convergent part:
kemdecap(kemcipher(kemencap(r,kempk(sk))),sk) = kemkey(kemencap(r,kempk(sk)))
fst((x_1,x_2)) = x_1
snd((x_1,x_2)) = x_2
Completing equations...
Completed equations:
snd((x_1,x_2)) = x_2
fst((x_1,x_2)) = x_1
kemdecap(kemcipher(kemencap(r,kempk(sk))),sk) = kemkey(kemencap(r,kempk(sk)))
Biprocess 0 (that is, the initial process):
{1}!
{2}new computerId_1: bitstring;
{3}new sk_1: bitstring;
{4}new sk_auth_kem_1: bitstring;
{5}new ltdh_1: bitstring;
{6}let idd_1: bitstring = id(pk(sk_1),ltdh_1,kempk(sk_auth_kem_1)) in
{7}out(att, (idd_1,(pk(sk_1),ltdh_1,kempk(sk_auth_kem_1))));
{8}event eShareLT(ltdh_1);
{9}event eHonest(pk(sk_1));
{10}event eHonest(kempk(sk_auth_kem_1));
{11}new sk_2: bitstring;
{12}new sk_auth_kem_2: bitstring;
{13}new ltdh_2: bitstring;
{14}new computerId_2: bitstring;
{15}let idd_2: bitstring = id(pk(sk_2),ltdh_2,kempk(sk_auth_kem_2)) in
{16}out(att, (idd_2,(pk(sk_2),ltdh_2,kempk(sk_auth_kem_2))));
{17}event eShareLT(ltdh_2);
{18}event eHonest(pk(sk_2));
{19}event eHonest(kempk(sk_auth_kem_2));
(
    {20}!
    {21}in(att, cred_2: bitstring);
    {22}let cid_2: bitstring = computerId_1 in
    {23}let skI_2: bitstring = sk_1 in
    {24}let I_2: bitstring = ltdh_1 in
    {25}let sk_kem_authI: bitstring = sk_auth_kem_1 in
    {26}in(att, (method_2: bitstring,(suitesI_2: bitstring,(C_I_2: bitstring,EAD_1_2: bitstring))));
    {27}event eMethodOk(method_2);
    {28}new X_2: bitstring;
    {29}new random_authR: bitstring;
    {30}new EAD_3_2: bitstring;
    {31}event eShare(X_2);
    {32}let CRED_I_2: bitstring = pk(skI_2) in
    {33}let KEM_CRED_I_2: bitstring = kempk(sk_kem_authI) in
    {34}let ID_CRED_I_2: bitstring = id(CRED_I_2,I_2,KEM_CRED_I_2) in
    {35}if (ID_CRED_I_2 ≠ cred_2) then
    {36}if (method_2 = method_four) then
    {37}let pkR_2: bitstring = get_kem_auth(cred_2) in
    {38}let encap_auth_R_2: bitstring = kemencap(random_authR,pkR_2) in
    {39}let K_AUTH_R_2: bitstring = kemkey(encap_auth_R_2) in
    {40}let CT_AUTH_R_2: bitstring = kemcipher(encap_auth_R_2) in
    {41}let plaintext_1_2: bitstring = ID_CRED_I_2 in
    {42}let G_X_2: bitstring = kempk(X_2) in
    {43}let TH_1_2: bitstring = hash((G_X_2,CT_AUTH_R_2)) in
    {44}let PRK_1e_2: bitstring = hkdfextract(TH_1_2,K_AUTH_R_2) in
    {45}let K_1_2: bitstring = edhoc_kdf(PRK_1e_2,szero,TH_1_2,key_length) in
    {46}let IV_1_2: bitstring = edhoc_kdf(PRK_1e_2,sone,TH_1_2,iv_length) in
    {47}let CIPHERTEXT_1_2: bitstring = aeadenc(plaintext_1_2,srep,K_1_2,IV_1_2) in
    {48}let m1_2: bitstring = (method_2,suitesI_2,G_X_2,C_I_2,EAD_1_2) in
    {49}out(att, m1_2);
    {50}in(att, m2_2: bitstring);
    {51}let (G_Y_2: bitstring,CIPHERTEXT_2_2: bitstring,CT_AUTH_I_2: bitstring) = m2_2 in
    {52}let mess_1_hash_2: bitstring = hash(m1_2) in
    {53}let TH_2_2: bitstring = hash((G_Y_2,mess_1_hash_2)) in
    {54}let G_YX_2: bitstring = kemdecap(G_Y_2,X_2) in
    {55}let PRK_2e_2: bitstring = hkdfextract(TH_2_2,G_YX_2) in
    {56}let KEYSTREAM_2_2: bitstring = edhoc_kdf(PRK_2e_2,stwo,TH_2_2,plaintext_length) in
    {57}let plaintext_2_2: bitstring = decxor(CIPHERTEXT_2_2,KEYSTREAM_2_2) in
    {58}let (C_R_2: bitstring,=cred_2,SIGNATURE_or_MAC_2_2: bitstring,EAD_2_2: bitstring) = plaintext_2_2 in
    {59}let pkI_2: bitstring = get_kem_auth(ID_CRED_I_2) in
    {60}let SALT_3e2m_2: bitstring = edhoc_kdf(PRK_2e_2,sthree,TH_2_2,hash_length) in
    {61}let PRK_3e2m_2: bitstring = hkdfextract(SALT_3e2m_2,K_AUTH_R_2) in
    {62}event eDerivedIShared(pkI_2,G_YX_2);
    {63}let MAC_2_2: bitstring = edhoc_kdf(PRK_3e2m_2,sfour,(cred_2,TH_2_2,pkR_2,EAD_2_2),hash_length) in
    {64}if (SIGNATURE_or_MAC_2_2 = MAC_2_2) then
    {65}event eCheckedMAC2(ID_CRED_I_2,MAC_2_2);
    {66}let TH_3_2: bitstring = hash((TH_2_2,(plaintext_2_2,pkR_2))) in
    {67}event eTHIShared(pkI_2,TH_3_2);
    {68}let K_3_2: bitstring = edhoc_kdf(PRK_3e2m_2,sfive,TH_3_2,key_length) in
    {69}let IV_3_2: bitstring = edhoc_kdf(PRK_3e2m_2,ssix,TH_3_2,iv_length) in
    {70}let SALT_4e3m_2: bitstring = edhoc_kdf(PRK_3e2m_2,sseven,TH_3_2,hash_length) in
    {71}let K_AUTH_I_2: bitstring = kemdecap(CT_AUTH_I_2,sk_kem_authI) in
    {72}let PRK_4e3m_2: bitstring = hkdfextract(SALT_4e3m_2,K_AUTH_I_2) in
    {73}let MAC_3_2: bitstring = edhoc_kdf(PRK_4e3m_2,seight,(ID_CRED_I_2,TH_3_2,pkI_2,EAD_3_2),hash_length) in
    {74}let SIGNATURE_or_MAC_3_2: bitstring = MAC_3_2 in
    {75}let plaintext_3_2: bitstring = (ID_CRED_I_2,(SIGNATURE_or_MAC_3_2,EAD_3_2)) in
    {76}let m3_2: bitstring = aeadenc(plaintext_3_2,srep,K_3_2,IV_3_2) in
    {77}let TH_4_2: bitstring = hash((TH_3_2,(plaintext_3_2,pkI_2))) in
    {78}let PRK_out_2: bitstring = edhoc_kdf(PRK_4e3m_2,snine,TH_4_2,hash_length) in
    {79}event eAcceptI(cid_2,method_four,pkI_2,pkR_2,PRK_3e2m_2,PRK_4e3m_2,PRK_out_2,X_2,G_Y_2);
    {80}event eSecretsI(cid_2,method_four,pkI_2,pkR_2,PRK_2e_2,PRK_3e2m_2,PRK_4e3m_2,PRK_out_2,KEYSTREAM_2_2,K_3_2,IV_3_2,X_2,G_Y_2);
    {81}event eAcceptIData(PRK_out_2,method_four,pkI_2,pkR_2,X_2,G_Y_2,(TH_1_2,TH_2_2,(TH_3_2,(TH_4_2,(suitesI_2,(EAD_1_2,(EAD_2_2,(EAD_3_2,(m1_2,(plaintext_1_2,plaintext_2_2,plaintext_3_2))))))))));
    (
        {82}out(att, m3_2)
    ) | (
        {83}event eLeakSessionKey(PRK_out_2);
        {84}out(att, PRK_out_2)
    )
) | (
    {85}!
    {86}in(att, cred_3: bitstring);
    {87}let cid: bitstring = computerId_2 in
    {88}let skI: bitstring = sk_2 in
    {89}let I_1: bitstring = ltdh_2 in
    {90}let sk_kem_authI_1: bitstring = sk_auth_kem_2 in
    {91}in(att, (method: bitstring,(suitesI: bitstring,(C_I: bitstring,EAD_1: bitstring))));
    {92}event eMethodOk(method);
    {93}new X: bitstring;
    {94}new random_authR_1: bitstring;
    {95}new EAD_3: bitstring;
    {96}event eShare(X);
    {97}let CRED_I: bitstring = pk(skI) in
    {98}let KEM_CRED_I: bitstring = kempk(sk_kem_authI_1) in
    {99}let ID_CRED_I: bitstring = id(CRED_I,I_1,KEM_CRED_I) in
    {100}if (ID_CRED_I ≠ cred_3) then
    {101}if (method = method_four) then
    {102}let pkR: bitstring = get_kem_auth(cred_3) in
    {103}let encap_auth_R: bitstring = kemencap(random_authR_1,pkR) in
    {104}let K_AUTH_R: bitstring = kemkey(encap_auth_R) in
    {105}let CT_AUTH_R: bitstring = kemcipher(encap_auth_R) in
    {106}let plaintext_1: bitstring = ID_CRED_I in
    {107}let G_X: bitstring = kempk(X) in
    {108}let TH_1: bitstring = hash((G_X,CT_AUTH_R)) in
    {109}let PRK_1e: bitstring = hkdfextract(TH_1,K_AUTH_R) in
    {110}let K_1: bitstring = edhoc_kdf(PRK_1e,szero,TH_1,key_length) in
    {111}let IV_1: bitstring = edhoc_kdf(PRK_1e,sone,TH_1,iv_length) in
    {112}let CIPHERTEXT_1: bitstring = aeadenc(plaintext_1,srep,K_1,IV_1) in
    {113}let m1: bitstring = (method,suitesI,G_X,C_I,EAD_1) in
    {114}out(att, m1);
    {115}in(att, m2: bitstring);
    {116}let (G_Y: bitstring,CIPHERTEXT_2: bitstring,CT_AUTH_I: bitstring) = m2 in
    {117}let mess_1_hash: bitstring = hash(m1) in
    {118}let TH_2: bitstring = hash((G_Y,mess_1_hash)) in
    {119}let G_YX: bitstring = kemdecap(G_Y,X) in
    {120}let PRK_2e: bitstring = hkdfextract(TH_2,G_YX) in
    {121}let KEYSTREAM_2: bitstring = edhoc_kdf(PRK_2e,stwo,TH_2,plaintext_length) in
    {122}let plaintext_2: bitstring = decxor(CIPHERTEXT_2,KEYSTREAM_2) in
    {123}let (C_R: bitstring,=cred_3,SIGNATURE_or_MAC_2: bitstring,EAD_2: bitstring) = plaintext_2 in
    {124}let pkI: bitstring = get_kem_auth(ID_CRED_I) in
    {125}let SALT_3e2m: bitstring = edhoc_kdf(PRK_2e,sthree,TH_2,hash_length) in
    {126}let PRK_3e2m: bitstring = hkdfextract(SALT_3e2m,K_AUTH_R) in
    {127}event eDerivedIShared(pkI,G_YX);
    {128}let MAC_2: bitstring = edhoc_kdf(PRK_3e2m,sfour,(cred_3,TH_2,pkR,EAD_2),hash_length) in
    {129}if (SIGNATURE_or_MAC_2 = MAC_2) then
    {130}event eCheckedMAC2(ID_CRED_I,MAC_2);
    {131}let TH_3: bitstring = hash((TH_2,(plaintext_2,pkR))) in
    {132}event eTHIShared(pkI,TH_3);
    {133}let K_3: bitstring = edhoc_kdf(PRK_3e2m,sfive,TH_3,key_length) in
    {134}let IV_3: bitstring = edhoc_kdf(PRK_3e2m,ssix,TH_3,iv_length) in
    {135}let SALT_4e3m: bitstring = edhoc_kdf(PRK_3e2m,sseven,TH_3,hash_length) in
    {136}let K_AUTH_I: bitstring = kemdecap(CT_AUTH_I,sk_kem_authI_1) in
    {137}let PRK_4e3m: bitstring = hkdfextract(SALT_4e3m,K_AUTH_I) in
    {138}let MAC_3: bitstring = edhoc_kdf(PRK_4e3m,seight,(ID_CRED_I,TH_3,pkI,EAD_3),hash_length) in
    {139}let SIGNATURE_or_MAC_3: bitstring = MAC_3 in
    {140}let plaintext_3: bitstring = (ID_CRED_I,(SIGNATURE_or_MAC_3,EAD_3)) in
    {141}let m3: bitstring = aeadenc(plaintext_3,srep,K_3,IV_3) in
    {142}let TH_4: bitstring = hash((TH_3,(plaintext_3,pkI))) in
    {143}let PRK_out: bitstring = edhoc_kdf(PRK_4e3m,snine,TH_4,hash_length) in
    {144}event eAcceptI(cid,method_four,pkI,pkR,PRK_3e2m,PRK_4e3m,PRK_out,X,G_Y);
    {145}event eSecretsI(cid,method_four,pkI,pkR,PRK_2e,PRK_3e2m,PRK_4e3m,PRK_out,KEYSTREAM_2,K_3,IV_3,X,G_Y);
    {146}event eAcceptIData(PRK_out,method_four,pkI,pkR,X,G_Y,(TH_1,TH_2,(TH_3,(TH_4,(suitesI,(EAD_1,(EAD_2,(EAD_3,(m1,(plaintext_1,plaintext_2,plaintext_3))))))))));
    (
        {147}out(att, m3)
    ) | (
        {148}event eLeakSessionKey(PRK_out);
        {149}out(att, PRK_out)
    )
) | (
    {150}!
    {151}let cid_1: bitstring = computerId_1 in
    {152}let skR_2: bitstring = sk_1 in
    {153}let R_2: bitstring = ltdh_1 in
    {154}let sk_kem_authR_2: bitstring = sk_auth_kem_1 in
    {155}in(att, (C_R_1: bitstring,(EAD_2_1: bitstring,suitesR_2: bitstring)));
    {156}in(att, m1_1: bitstring);
    {157}let (method_1: bitstring,suitesI_1: bitstring,G_X_1: bitstring,C_I_1: bitstring,CT_AUTH_R_1: bitstring,CIPHERTEXT_1_1: bitstring,EAD_1_1: bitstring) = m1_1 in
    {158}event eMethodOk(method_1);
    {159}new Y_2: bitstring;
    {160}event eShare(Y_2);
    {161}let G_R_2: bitstring = R_2 in
    {162}let encapsulation: bitstring = kemencap(Y_2,G_X_1) in
    {163}let G_Y_1: bitstring = kemcipher(encapsulation) in
    {164}let G_XY_2: bitstring = kemkey(encapsulation) in
    {165}let CRED_R_2: bitstring = pk(skR_2) in
    {166}let KEM_CRED_R_2: bitstring = kempk(sk_kem_authR_2) in
    {167}let ID_CRED_R_2: bitstring = id(CRED_R_2,G_R_2,KEM_CRED_R_2) in
    {168}if (method_1 = method_four) then
    {169}let K_AUTH_R_1: bitstring = kemdecap(CT_AUTH_R_1,sk_kem_authR_2) in
    {170}let TH_1_1: bitstring = hash((G_X_1,CT_AUTH_R_1)) in
    {171}let PRK_1e_1: bitstring = hkdfextract(TH_1_1,K_AUTH_R_1) in
    {172}let K_1_1: bitstring = edhoc_kdf(PRK_1e_1,szero,TH_1_1,key_length) in
    {173}let IV_1_1: bitstring = edhoc_kdf(PRK_1e_1,sone,TH_1_1,iv_length) in
    {174}let plaintext_1_1: bitstring = aeaddec(CIPHERTEXT_1_1,K_1_1,IV_1_1) in
    {175}let ID_CRED_I_1: bitstring = plaintext_1_1 in
    {176}if (ID_CRED_R_2 ≠ ID_CRED_I_1) then
    {177}let mess_1_hash_1: bitstring = hash(m1_1) in
    {178}let TH_2_1: bitstring = hash((G_Y_1,mess_1_hash_1)) in
    {179}let PRK_2e_1: bitstring = hkdfextract(TH_2_1,G_XY_2) in
    {180}let pkR_1: bitstring = get_kem_auth(ID_CRED_R_2) in
    {181}let pkI_1: bitstring = get_kem_auth(ID_CRED_I_1) in
    {182}let KEYSTREAM_2_1: bitstring = edhoc_kdf(PRK_2e_1,stwo,TH_2_1,plaintext_length) in
    {183}let SALT_3e2m_1: bitstring = edhoc_kdf(PRK_2e_1,sthree,TH_2_1,hash_length) in
    {184}let PRK_3e2m_1: bitstring = hkdfextract(SALT_3e2m_1,K_AUTH_R_1) in
    {185}let MAC_2_1: bitstring = edhoc_kdf(PRK_3e2m_1,sfour,(ID_CRED_R_2,TH_2_1,pkR_1,EAD_2_1),hash_length) in
    {186}let SIGNATURE_or_MAC_2_1: bitstring = MAC_2_1 in
    {187}let plaintext_2_1: bitstring = (C_R_1,(ID_CRED_R_2,(SIGNATURE_or_MAC_2_1,EAD_2_1))) in
    {188}event eDerivedR(cid_1,pkR_1,PRK_3e2m_1,Y_2,G_X_1);
    {189}event eTHRShared(pkR_1,TH_2_1);
    {190}event eDerivedRShared(pkR_1,G_XY_2);
    {191}event eDerivedIdR(ID_CRED_R_2,PRK_3e2m_1);
    {192}new encap_auth_random_seed: bitstring;
    {193}let encap_auth_I_2: bitstring = kemencap(encap_auth_random_seed,pkI_1) in
    {194}let K_AUTH_I_1: bitstring = kemkey(encap_auth_I_2) in
    {195}let CT_AUTH_I_1: bitstring = kemcipher(encap_auth_I_2) in
    {196}let m2_1: bitstring = (G_Y_1,encxor(plaintext_2_1,KEYSTREAM_2_1)) in
    {197}event eSendRData(method_four,pkR_1,(TH_1_1,TH_2_1,(suitesI_1,(EAD_1_1,(EAD_2_1,(m1_1,plaintext_1_1,plaintext_2_1))))));
    {198}out(att, m2_1);
    {199}in(att, CIPHERTEXT_3_2: bitstring);
    {200}let TH_3_1: bitstring = hash((TH_2_1,(plaintext_2_1,pkR_1))) in
    {201}let K_3_1: bitstring = edhoc_kdf(PRK_3e2m_1,sfive,TH_3_1,key_length) in
    {202}let IV_3_1: bitstring = edhoc_kdf(PRK_3e2m_1,ssix,TH_3_1,iv_length) in
    {203}let SALT_4e3m_1: bitstring = edhoc_kdf(PRK_3e2m_1,sseven,TH_3_1,hash_length) in
    {204}let PRK_4e3m_1: bitstring = hkdfextract(SALT_4e3m_1,K_AUTH_I_1) in
    {205}let plaintext_3_1: bitstring = aeaddec(CIPHERTEXT_3_2,K_3_1,IV_3_1) in
    {206}let (=ID_CRED_I_1,(SIGNATURE_or_MAC_3_1: bitstring,EAD_3_1: bitstring)) = plaintext_3_1 in
    {207}let pkI_3: bitstring = get_kem_auth(ID_CRED_I_1) in
    {208}let MAC_3_1: bitstring = edhoc_kdf(PRK_4e3m_1,seight,(ID_CRED_I_1,TH_3_1,pkI_3,EAD_3_1),hash_length) in
    {209}if (SIGNATURE_or_MAC_3_1 = MAC_3_1) then
    {210}event eCheckedMAC3(ID_CRED_R_2,MAC_3_1);
    {211}let TH_4_1: bitstring = hash((TH_3_1,(plaintext_3_1,pkI_3))) in
    {212}let PRK_out_1: bitstring = edhoc_kdf(PRK_4e3m_1,snine,TH_4_1,hash_length) in
    {213}event eAcceptR(cid_1,method_four,pkI_3,pkR_1,PRK_3e2m_1,PRK_4e3m_1,PRK_out_1,Y_2,G_X_1);
    {214}event eSecretsR(cid_1,method_four,pkI_3,pkR_1,PRK_2e_1,PRK_3e2m_1,PRK_4e3m_1,PRK_out_1,KEYSTREAM_2_1,K_3_1,IV_3_1,Y_2,G_X_1);
    (
        {215}event eAcceptRData(PRK_out_1,method_four,pkI_3,pkR_1,Y_2,G_X_1,(TH_1_1,TH_2_1,(TH_3_1,(TH_4_1,(suitesI_1,(EAD_1_1,(EAD_2_1,(EAD_3_1,(m1_1,(plaintext_1_1,plaintext_2_1,plaintext_3_1))))))))))
    ) | (
        {216}event eLeakSessionKey(PRK_out_1);
        {217}out(att, PRK_out_1)
    )
) | (
    {218}!
    {219}let cid_3: bitstring = computerId_2 in
    {220}let skR: bitstring = sk_2 in
    {221}let R_1: bitstring = ltdh_2 in
    {222}let sk_kem_authR: bitstring = sk_auth_kem_2 in
    {223}in(att, (C_R_3: bitstring,(EAD_2_3: bitstring,suitesR: bitstring)));
    {224}in(att, m1_3: bitstring);
    {225}let (method_3: bitstring,suitesI_3: bitstring,G_X_3: bitstring,C_I_3: bitstring,CT_AUTH_R_3: bitstring,CIPHERTEXT_1_3: bitstring,EAD_1_3: bitstring) = m1_3 in
    {226}event eMethodOk(method_3);
    {227}new Y: bitstring;
    {228}event eShare(Y);
    {229}let G_R: bitstring = R_1 in
    {230}let encapsulation_1: bitstring = kemencap(Y,G_X_3) in
    {231}let G_Y_3: bitstring = kemcipher(encapsulation_1) in
    {232}let G_XY: bitstring = kemkey(encapsulation_1) in
    {233}let CRED_R: bitstring = pk(skR) in
    {234}let KEM_CRED_R: bitstring = kempk(sk_kem_authR) in
    {235}let ID_CRED_R: bitstring = id(CRED_R,G_R,KEM_CRED_R) in
    {236}if (method_3 = method_four) then
    {237}let K_AUTH_R_3: bitstring = kemdecap(CT_AUTH_R_3,sk_kem_authR) in
    {238}let TH_1_3: bitstring = hash((G_X_3,CT_AUTH_R_3)) in
    {239}let PRK_1e_3: bitstring = hkdfextract(TH_1_3,K_AUTH_R_3) in
    {240}let K_1_3: bitstring = edhoc_kdf(PRK_1e_3,szero,TH_1_3,key_length) in
    {241}let IV_1_3: bitstring = edhoc_kdf(PRK_1e_3,sone,TH_1_3,iv_length) in
    {242}let plaintext_1_3: bitstring = aeaddec(CIPHERTEXT_1_3,K_1_3,IV_1_3) in
    {243}let ID_CRED_I_3: bitstring = plaintext_1_3 in
    {244}if (ID_CRED_R ≠ ID_CRED_I_3) then
    {245}let mess_1_hash_3: bitstring = hash(m1_3) in
    {246}let TH_2_3: bitstring = hash((G_Y_3,mess_1_hash_3)) in
    {247}let PRK_2e_3: bitstring = hkdfextract(TH_2_3,G_XY) in
    {248}let pkR_3: bitstring = get_kem_auth(ID_CRED_R) in
    {249}let pkI_4: bitstring = get_kem_auth(ID_CRED_I_3) in
    {250}let KEYSTREAM_2_3: bitstring = edhoc_kdf(PRK_2e_3,stwo,TH_2_3,plaintext_length) in
    {251}let SALT_3e2m_3: bitstring = edhoc_kdf(PRK_2e_3,sthree,TH_2_3,hash_length) in
    {252}let PRK_3e2m_3: bitstring = hkdfextract(SALT_3e2m_3,K_AUTH_R_3) in
    {253}let MAC_2_3: bitstring = edhoc_kdf(PRK_3e2m_3,sfour,(ID_CRED_R,TH_2_3,pkR_3,EAD_2_3),hash_length) in
    {254}let SIGNATURE_or_MAC_2_3: bitstring = MAC_2_3 in
    {255}let plaintext_2_3: bitstring = (C_R_3,(ID_CRED_R,(SIGNATURE_or_MAC_2_3,EAD_2_3))) in
    {256}event eDerivedR(cid_3,pkR_3,PRK_3e2m_3,Y,G_X_3);
    {257}event eTHRShared(pkR_3,TH_2_3);
    {258}event eDerivedRShared(pkR_3,G_XY);
    {259}event eDerivedIdR(ID_CRED_R,PRK_3e2m_3);
    {260}new encap_auth_random_seed_1: bitstring;
    {261}let encap_auth_I: bitstring = kemencap(encap_auth_random_seed_1,pkI_4) in
    {262}let K_AUTH_I_3: bitstring = kemkey(encap_auth_I) in
    {263}let CT_AUTH_I_3: bitstring = kemcipher(encap_auth_I) in
    {264}let m2_3: bitstring = (G_Y_3,encxor(plaintext_2_3,KEYSTREAM_2_3)) in
    {265}event eSendRData(method_four,pkR_3,(TH_1_3,TH_2_3,(suitesI_3,(EAD_1_3,(EAD_2_3,(m1_3,plaintext_1_3,plaintext_2_3))))));
    {266}out(att, m2_3);
    {267}in(att, CIPHERTEXT_3: bitstring);
    {268}let TH_3_3: bitstring = hash((TH_2_3,(plaintext_2_3,pkR_3))) in
    {269}let K_3_3: bitstring = edhoc_kdf(PRK_3e2m_3,sfive,TH_3_3,key_length) in
    {270}let IV_3_3: bitstring = edhoc_kdf(PRK_3e2m_3,ssix,TH_3_3,iv_length) in
    {271}let SALT_4e3m_3: bitstring = edhoc_kdf(PRK_3e2m_3,sseven,TH_3_3,hash_length) in
    {272}let PRK_4e3m_3: bitstring = hkdfextract(SALT_4e3m_3,K_AUTH_I_3) in
    {273}let plaintext_3_3: bitstring = aeaddec(CIPHERTEXT_3,K_3_3,IV_3_3) in
    {274}let (=ID_CRED_I_3,(SIGNATURE_or_MAC_3_3: bitstring,EAD_3_3: bitstring)) = plaintext_3_3 in
    {275}let pkI_5: bitstring = get_kem_auth(ID_CRED_I_3) in
    {276}let MAC_3_3: bitstring = edhoc_kdf(PRK_4e3m_3,seight,(ID_CRED_I_3,TH_3_3,pkI_5,EAD_3_3),hash_length) in
    {277}if (SIGNATURE_or_MAC_3_3 = MAC_3_3) then
    {278}event eCheckedMAC3(ID_CRED_R,MAC_3_3);
    {279}let TH_4_3: bitstring = hash((TH_3_3,(plaintext_3_3,pkI_5))) in
    {280}let PRK_out_3: bitstring = edhoc_kdf(PRK_4e3m_3,snine,TH_4_3,hash_length) in
    {281}event eAcceptR(cid_3,method_four,pkI_5,pkR_3,PRK_3e2m_3,PRK_4e3m_3,PRK_out_3,Y,G_X_3);
    {282}event eSecretsR(cid_3,method_four,pkI_5,pkR_3,PRK_2e_3,PRK_3e2m_3,PRK_4e3m_3,PRK_out_3,KEYSTREAM_2_3,K_3_3,IV_3_3,Y,G_X_3);
    (
        {283}event eAcceptRData(PRK_out_3,method_four,pkI_5,pkR_3,Y,G_X_3,(TH_1_3,TH_2_3,(TH_3_3,(TH_4_3,(suitesI_3,(EAD_1_3,(EAD_2_3,(EAD_3_3,(m1_3,(plaintext_1_3,plaintext_2_3,plaintext_3_3))))))))))
    ) | (
        {284}event eLeakSessionKey(PRK_out_3);
        {285}out(att, PRK_out_3)
    )
) | (
    {286}!
    {287}let cid_4: bitstring = choice[computerId_1,computerId_2] in
    {288}let skI_1: bitstring = choice[sk_1,sk_2] in
    {289}let I_3: bitstring = choice[ltdh_1,ltdh_2] in
    {290}let sk_kem_authI_2: bitstring = choice[sk_auth_kem_1,sk_auth_kem_2] in
    {291}in(att, (method_4: bitstring,(suitesI_4: bitstring,(C_I_4: bitstring,EAD_1_4: bitstring))));
    {292}event eMethodOk(method_4);
    {293}new X_1: bitstring;
    {294}new random_authR_2: bitstring;
    {295}new EAD_3_4: bitstring;
    {296}event eShare(X_1);
    {297}let CRED_I_1: bitstring = pk(skI_1) in
    {298}let KEM_CRED_I_1: bitstring = kempk(sk_kem_authI_2) in
    {299}let ID_CRED_I_4: bitstring = id(CRED_I_1,I_3,KEM_CRED_I_1) in
    {300}if (ID_CRED_I_4 ≠ idd_2) then
    {301}if (method_4 = method_four) then
    {302}let pkR_4: bitstring = get_kem_auth(idd_2) in
    {303}let encap_auth_R_1: bitstring = kemencap(random_authR_2,pkR_4) in
    {304}let K_AUTH_R_4: bitstring = kemkey(encap_auth_R_1) in
    {305}let CT_AUTH_R_4: bitstring = kemcipher(encap_auth_R_1) in
    {306}let plaintext_1_4: bitstring = ID_CRED_I_4 in
    {307}let G_X_4: bitstring = kempk(X_1) in
    {308}let TH_1_4: bitstring = hash((G_X_4,CT_AUTH_R_4)) in
    {309}let PRK_1e_4: bitstring = hkdfextract(TH_1_4,K_AUTH_R_4) in
    {310}let K_1_4: bitstring = edhoc_kdf(PRK_1e_4,szero,TH_1_4,key_length) in
    {311}let IV_1_4: bitstring = edhoc_kdf(PRK_1e_4,sone,TH_1_4,iv_length) in
    {312}let CIPHERTEXT_1_4: bitstring = aeadenc(plaintext_1_4,srep,K_1_4,IV_1_4) in
    {313}let m1_4: bitstring = (method_4,suitesI_4,G_X_4,C_I_4,EAD_1_4) in
    {314}out(att, m1_4);
    {315}in(att, m2_4: bitstring);
    {316}let (G_Y_4: bitstring,CIPHERTEXT_2_1: bitstring,CT_AUTH_I_4: bitstring) = m2_4 in
    {317}let mess_1_hash_4: bitstring = hash(m1_4) in
    {318}let TH_2_4: bitstring = hash((G_Y_4,mess_1_hash_4)) in
    {319}let G_YX_1: bitstring = kemdecap(G_Y_4,X_1) in
    {320}let PRK_2e_4: bitstring = hkdfextract(TH_2_4,G_YX_1) in
    {321}let KEYSTREAM_2_4: bitstring = edhoc_kdf(PRK_2e_4,stwo,TH_2_4,plaintext_length) in
    {322}let plaintext_2_4: bitstring = decxor(CIPHERTEXT_2_1,KEYSTREAM_2_4) in
    {323}let (C_R_4: bitstring,=idd_2,SIGNATURE_or_MAC_2_4: bitstring,EAD_2_4: bitstring) = plaintext_2_4 in
    {324}let pkI_6: bitstring = get_kem_auth(ID_CRED_I_4) in
    {325}let SALT_3e2m_4: bitstring = edhoc_kdf(PRK_2e_4,sthree,TH_2_4,hash_length) in
    {326}let PRK_3e2m_4: bitstring = hkdfextract(SALT_3e2m_4,K_AUTH_R_4) in
    {327}event eDerivedIShared(pkI_6,G_YX_1);
    {328}let MAC_2_4: bitstring = edhoc_kdf(PRK_3e2m_4,sfour,(idd_2,TH_2_4,pkR_4,EAD_2_4),hash_length) in
    {329}if (SIGNATURE_or_MAC_2_4 = MAC_2_4) then
    {330}event eCheckedMAC2(ID_CRED_I_4,MAC_2_4);
    {331}let TH_3_4: bitstring = hash((TH_2_4,(plaintext_2_4,pkR_4))) in
    {332}event eTHIShared(pkI_6,TH_3_4);
    {333}let K_3_4: bitstring = edhoc_kdf(PRK_3e2m_4,sfive,TH_3_4,key_length) in
    {334}let IV_3_4: bitstring = edhoc_kdf(PRK_3e2m_4,ssix,TH_3_4,iv_length) in
    {335}let SALT_4e3m_4: bitstring = edhoc_kdf(PRK_3e2m_4,sseven,TH_3_4,hash_length) in
    {336}let K_AUTH_I_4: bitstring = kemdecap(CT_AUTH_I_4,sk_kem_authI_2) in
    {337}let PRK_4e3m_4: bitstring = hkdfextract(SALT_4e3m_4,K_AUTH_I_4) in
    {338}let MAC_3_4: bitstring = edhoc_kdf(PRK_4e3m_4,seight,(ID_CRED_I_4,TH_3_4,pkI_6,EAD_3_4),hash_length) in
    {339}let SIGNATURE_or_MAC_3_4: bitstring = MAC_3_4 in
    {340}let plaintext_3_4: bitstring = (ID_CRED_I_4,(SIGNATURE_or_MAC_3_4,EAD_3_4)) in
    {341}let m3_1: bitstring = aeadenc(plaintext_3_4,srep,K_3_4,IV_3_4) in
    {342}let TH_4_4: bitstring = hash((TH_3_4,(plaintext_3_4,pkI_6))) in
    {343}let PRK_out_4: bitstring = edhoc_kdf(PRK_4e3m_4,snine,TH_4_4,hash_length) in
    {344}event eAcceptI(cid_4,method_four,pkI_6,pkR_4,PRK_3e2m_4,PRK_4e3m_4,PRK_out_4,X_1,G_Y_4);
    {345}event eSecretsI(cid_4,method_four,pkI_6,pkR_4,PRK_2e_4,PRK_3e2m_4,PRK_4e3m_4,PRK_out_4,KEYSTREAM_2_4,K_3_4,IV_3_4,X_1,G_Y_4);
    {346}event eAcceptIData(PRK_out_4,method_four,pkI_6,pkR_4,X_1,G_Y_4,(TH_1_4,TH_2_4,(TH_3_4,(TH_4_4,(suitesI_4,(EAD_1_4,(EAD_2_4,(EAD_3_4,(m1_4,(plaintext_1_4,plaintext_2_4,plaintext_3_4))))))))));
    (
        {347}out(att, m3_1)
    ) | (
        {348}event eLeakSessionKey(PRK_out_4);
        {349}out(att, PRK_out_4)
    )
) | (
    {350}phase 1;
    {351}event eCompromise(kempk(sk_auth_kem_1));
    {352}event eCompromise(kempk(sk_auth_kem_2));
    {353}out(att, sk_auth_kem_1);
    {354}out(att, sk_auth_kem_2)
)

-- Observational equivalence in biprocess 1 (that is, biprocess 0, with let moved downwards):
{1}!
{2}new computerId_1: bitstring;
{3}new sk_1: bitstring;
{4}new sk_auth_kem_1: bitstring;
{5}new ltdh_1: bitstring;
{6}let idd_1: bitstring = id(pk(sk_1),ltdh_1,kempk(sk_auth_kem_1)) in
{7}out(att, (idd_1,(pk(sk_1),ltdh_1,kempk(sk_auth_kem_1))));
{8}event eShareLT(ltdh_1);
{9}event eHonest(pk(sk_1));
{10}event eHonest(kempk(sk_auth_kem_1));
{11}new sk_2: bitstring;
{12}new sk_auth_kem_2: bitstring;
{13}new ltdh_2: bitstring;
{14}new computerId_2: bitstring;
{15}let idd_2: bitstring = id(pk(sk_2),ltdh_2,kempk(sk_auth_kem_2)) in
{16}out(att, (idd_2,(pk(sk_2),ltdh_2,kempk(sk_auth_kem_2))));
{17}event eShareLT(ltdh_2);
{18}event eHonest(pk(sk_2));
{19}event eHonest(kempk(sk_auth_kem_2));
(
    {20}!
    {21}in(att, cred_2: bitstring);
    {26}in(att, (method_2: bitstring,(suitesI_2: bitstring,(C_I_2: bitstring,EAD_1_2: bitstring))));
    {27}event eMethodOk(method_2);
    {28}new X_2: bitstring;
    {29}new random_authR: bitstring;
    {30}new EAD_3_2: bitstring;
    {31}event eShare(X_2);
    {25}let sk_kem_authI: bitstring = sk_auth_kem_1 in
    {33}let KEM_CRED_I_2: bitstring = kempk(sk_kem_authI) in
    {23}let skI_2: bitstring = sk_1 in
    {32}let CRED_I_2: bitstring = pk(skI_2) in
    {24}let I_2: bitstring = ltdh_1 in
    {34}let ID_CRED_I_2: bitstring = id(CRED_I_2,I_2,KEM_CRED_I_2) in
    {35}if (ID_CRED_I_2 ≠ cred_2) then
    {36}if (method_2 = method_four) then
    {37}let pkR_2: bitstring = get_kem_auth(cred_2) in
    {42}let G_X_2: bitstring = kempk(X_2) in
    {48}let m1_2: bitstring = (method_2,suitesI_2,G_X_2,C_I_2,EAD_1_2) in
    {49}out(att, m1_2);
    {50}in(att, m2_2: bitstring);
    {51}let (G_Y_2: bitstring,CIPHERTEXT_2_2: bitstring,CT_AUTH_I_2: bitstring) = m2_2 in
    {54}let G_YX_2: bitstring = kemdecap(G_Y_2,X_2) in
    {52}let mess_1_hash_2: bitstring = hash(m1_2) in
    {53}let TH_2_2: bitstring = hash((G_Y_2,mess_1_hash_2)) in
    {55}let PRK_2e_2: bitstring = hkdfextract(TH_2_2,G_YX_2) in
    {56}let KEYSTREAM_2_2: bitstring = edhoc_kdf(PRK_2e_2,stwo,TH_2_2,plaintext_length) in
    {57}let plaintext_2_2: bitstring = decxor(CIPHERTEXT_2_2,KEYSTREAM_2_2) in
    {58}let (C_R_2: bitstring,=cred_2,SIGNATURE_or_MAC_2_2: bitstring,EAD_2_2: bitstring) = plaintext_2_2 in
    {59}let pkI_2: bitstring = get_kem_auth(ID_CRED_I_2) in
    {62}event eDerivedIShared(pkI_2,G_YX_2);
    {60}let SALT_3e2m_2: bitstring = edhoc_kdf(PRK_2e_2,sthree,TH_2_2,hash_length) in
    {38}let encap_auth_R_2: bitstring = kemencap(random_authR,pkR_2) in
    {39}let K_AUTH_R_2: bitstring = kemkey(encap_auth_R_2) in
    {61}let PRK_3e2m_2: bitstring = hkdfextract(SALT_3e2m_2,K_AUTH_R_2) in
    {63}let MAC_2_2: bitstring = edhoc_kdf(PRK_3e2m_2,sfour,(cred_2,TH_2_2,pkR_2,EAD_2_2),hash_length) in
    {64}if (SIGNATURE_or_MAC_2_2 = MAC_2_2) then
    {65}event eCheckedMAC2(ID_CRED_I_2,MAC_2_2);
    {66}let TH_3_2: bitstring = hash((TH_2_2,(plaintext_2_2,pkR_2))) in
    {67}event eTHIShared(pkI_2,TH_3_2);
    {71}let K_AUTH_I_2: bitstring = kemdecap(CT_AUTH_I_2,sk_kem_authI) in
    {70}let SALT_4e3m_2: bitstring = edhoc_kdf(PRK_3e2m_2,sseven,TH_3_2,hash_length) in
    {72}let PRK_4e3m_2: bitstring = hkdfextract(SALT_4e3m_2,K_AUTH_I_2) in
    {73}let MAC_3_2: bitstring = edhoc_kdf(PRK_4e3m_2,seight,(ID_CRED_I_2,TH_3_2,pkI_2,EAD_3_2),hash_length) in
    {74}let SIGNATURE_or_MAC_3_2: bitstring = MAC_3_2 in
    {75}let plaintext_3_2: bitstring = (ID_CRED_I_2,(SIGNATURE_or_MAC_3_2,EAD_3_2)) in
    {77}let TH_4_2: bitstring = hash((TH_3_2,(plaintext_3_2,pkI_2))) in
    {78}let PRK_out_2: bitstring = edhoc_kdf(PRK_4e3m_2,snine,TH_4_2,hash_length) in
    {22}let cid_2: bitstring = computerId_1 in
    {79}event eAcceptI(cid_2,method_four,pkI_2,pkR_2,PRK_3e2m_2,PRK_4e3m_2,PRK_out_2,X_2,G_Y_2);
    {69}let IV_3_2: bitstring = edhoc_kdf(PRK_3e2m_2,ssix,TH_3_2,iv_length) in
    {68}let K_3_2: bitstring = edhoc_kdf(PRK_3e2m_2,sfive,TH_3_2,key_length) in
    {80}event eSecretsI(cid_2,method_four,pkI_2,pkR_2,PRK_2e_2,PRK_3e2m_2,PRK_4e3m_2,PRK_out_2,KEYSTREAM_2_2,K_3_2,IV_3_2,X_2,G_Y_2);
    {40}let CT_AUTH_R_2: bitstring = kemcipher(encap_auth_R_2) in
    {43}let TH_1_2: bitstring = hash((G_X_2,CT_AUTH_R_2)) in
    {41}let plaintext_1_2: bitstring = ID_CRED_I_2 in
    {81}event eAcceptIData(PRK_out_2,method_four,pkI_2,pkR_2,X_2,G_Y_2,(TH_1_2,TH_2_2,(TH_3_2,(TH_4_2,(suitesI_2,(EAD_1_2,(EAD_2_2,(EAD_3_2,(m1_2,(plaintext_1_2,plaintext_2_2,plaintext_3_2))))))))));
    (
        {76}let m3_2: bitstring = aeadenc(plaintext_3_2,srep,K_3_2,IV_3_2) in
        {82}out(att, m3_2)
    ) | (
        {83}event eLeakSessionKey(PRK_out_2);
        {84}out(att, PRK_out_2)
    )
) | (
    {85}!
    {86}in(att, cred_3: bitstring);
    {91}in(att, (method: bitstring,(suitesI: bitstring,(C_I: bitstring,EAD_1: bitstring))));
    {92}event eMethodOk(method);
    {93}new X: bitstring;
    {94}new random_authR_1: bitstring;
    {95}new EAD_3: bitstring;
    {96}event eShare(X);
    {90}let sk_kem_authI_1: bitstring = sk_auth_kem_2 in
    {98}let KEM_CRED_I: bitstring = kempk(sk_kem_authI_1) in
    {88}let skI: bitstring = sk_2 in
    {97}let CRED_I: bitstring = pk(skI) in
    {89}let I_1: bitstring = ltdh_2 in
    {99}let ID_CRED_I: bitstring = id(CRED_I,I_1,KEM_CRED_I) in
    {100}if (ID_CRED_I ≠ cred_3) then
    {101}if (method = method_four) then
    {102}let pkR: bitstring = get_kem_auth(cred_3) in
    {107}let G_X: bitstring = kempk(X) in
    {113}let m1: bitstring = (method,suitesI,G_X,C_I,EAD_1) in
    {114}out(att, m1);
    {115}in(att, m2: bitstring);
    {116}let (G_Y: bitstring,CIPHERTEXT_2: bitstring,CT_AUTH_I: bitstring) = m2 in
    {119}let G_YX: bitstring = kemdecap(G_Y,X) in
    {117}let mess_1_hash: bitstring = hash(m1) in
    {118}let TH_2: bitstring = hash((G_Y,mess_1_hash)) in
    {120}let PRK_2e: bitstring = hkdfextract(TH_2,G_YX) in
    {121}let KEYSTREAM_2: bitstring = edhoc_kdf(PRK_2e,stwo,TH_2,plaintext_length) in
    {122}let plaintext_2: bitstring = decxor(CIPHERTEXT_2,KEYSTREAM_2) in
    {123}let (C_R: bitstring,=cred_3,SIGNATURE_or_MAC_2: bitstring,EAD_2: bitstring) = plaintext_2 in
    {124}let pkI: bitstring = get_kem_auth(ID_CRED_I) in
    {127}event eDerivedIShared(pkI,G_YX);
    {125}let SALT_3e2m: bitstring = edhoc_kdf(PRK_2e,sthree,TH_2,hash_length) in
    {103}let encap_auth_R: bitstring = kemencap(random_authR_1,pkR) in
    {104}let K_AUTH_R: bitstring = kemkey(encap_auth_R) in
    {126}let PRK_3e2m: bitstring = hkdfextract(SALT_3e2m,K_AUTH_R) in
    {128}let MAC_2: bitstring = edhoc_kdf(PRK_3e2m,sfour,(cred_3,TH_2,pkR,EAD_2),hash_length) in
    {129}if (SIGNATURE_or_MAC_2 = MAC_2) then
    {130}event eCheckedMAC2(ID_CRED_I,MAC_2);
    {131}let TH_3: bitstring = hash((TH_2,(plaintext_2,pkR))) in
    {132}event eTHIShared(pkI,TH_3);
    {136}let K_AUTH_I: bitstring = kemdecap(CT_AUTH_I,sk_kem_authI_1) in
    {135}let SALT_4e3m: bitstring = edhoc_kdf(PRK_3e2m,sseven,TH_3,hash_length) in
    {137}let PRK_4e3m: bitstring = hkdfextract(SALT_4e3m,K_AUTH_I) in
    {138}let MAC_3: bitstring = edhoc_kdf(PRK_4e3m,seight,(ID_CRED_I,TH_3,pkI,EAD_3),hash_length) in
    {139}let SIGNATURE_or_MAC_3: bitstring = MAC_3 in
    {140}let plaintext_3: bitstring = (ID_CRED_I,(SIGNATURE_or_MAC_3,EAD_3)) in
    {142}let TH_4: bitstring = hash((TH_3,(plaintext_3,pkI))) in
    {143}let PRK_out: bitstring = edhoc_kdf(PRK_4e3m,snine,TH_4,hash_length) in
    {87}let cid: bitstring = computerId_2 in
    {144}event eAcceptI(cid,method_four,pkI,pkR,PRK_3e2m,PRK_4e3m,PRK_out,X,G_Y);
    {134}let IV_3: bitstring = edhoc_kdf(PRK_3e2m,ssix,TH_3,iv_length) in
    {133}let K_3: bitstring = edhoc_kdf(PRK_3e2m,sfive,TH_3,key_length) in
    {145}event eSecretsI(cid,method_four,pkI,pkR,PRK_2e,PRK_3e2m,PRK_4e3m,PRK_out,KEYSTREAM_2,K_3,IV_3,X,G_Y);
    {105}let CT_AUTH_R: bitstring = kemcipher(encap_auth_R) in
    {108}let TH_1: bitstring = hash((G_X,CT_AUTH_R)) in
    {106}let plaintext_1: bitstring = ID_CRED_I in
    {146}event eAcceptIData(PRK_out,method_four,pkI,pkR,X,G_Y,(TH_1,TH_2,(TH_3,(TH_4,(suitesI,(EAD_1,(EAD_2,(EAD_3,(m1,(plaintext_1,plaintext_2,plaintext_3))))))))));
    (
        {141}let m3: bitstring = aeadenc(plaintext_3,srep,K_3,IV_3) in
        {147}out(att, m3)
    ) | (
        {148}event eLeakSessionKey(PRK_out);
        {149}out(att, PRK_out)
    )
) | (
    {150}!
    {155}in(att, (C_R_1: bitstring,(EAD_2_1: bitstring,suitesR_2: bitstring)));
    {156}in(att, m1_1: bitstring);
    {157}let (method_1: bitstring,suitesI_1: bitstring,G_X_1: bitstring,C_I_1: bitstring,CT_AUTH_R_1: bitstring,CIPHERTEXT_1_1: bitstring,EAD_1_1: bitstring) = m1_1 in
    {158}event eMethodOk(method_1);
    {159}new Y_2: bitstring;
    {160}event eShare(Y_2);
    {168}if (method_1 = method_four) then
    {170}let TH_1_1: bitstring = hash((G_X_1,CT_AUTH_R_1)) in
    {154}let sk_kem_authR_2: bitstring = sk_auth_kem_1 in
    {169}let K_AUTH_R_1: bitstring = kemdecap(CT_AUTH_R_1,sk_kem_authR_2) in
    {171}let PRK_1e_1: bitstring = hkdfextract(TH_1_1,K_AUTH_R_1) in
    {173}let IV_1_1: bitstring = edhoc_kdf(PRK_1e_1,sone,TH_1_1,iv_length) in
    {172}let K_1_1: bitstring = edhoc_kdf(PRK_1e_1,szero,TH_1_1,key_length) in
    {174}let plaintext_1_1: bitstring = aeaddec(CIPHERTEXT_1_1,K_1_1,IV_1_1) in
    {175}let ID_CRED_I_1: bitstring = plaintext_1_1 in
    {166}let KEM_CRED_R_2: bitstring = kempk(sk_kem_authR_2) in
    {152}let skR_2: bitstring = sk_1 in
    {165}let CRED_R_2: bitstring = pk(skR_2) in
    {153}let R_2: bitstring = ltdh_1 in
    {161}let G_R_2: bitstring = R_2 in
    {167}let ID_CRED_R_2: bitstring = id(CRED_R_2,G_R_2,KEM_CRED_R_2) in
    {176}if (ID_CRED_R_2 ≠ ID_CRED_I_1) then
    {180}let pkR_1: bitstring = get_kem_auth(ID_CRED_R_2) in
    {181}let pkI_1: bitstring = get_kem_auth(ID_CRED_I_1) in
    {177}let mess_1_hash_1: bitstring = hash(m1_1) in
    {162}let encapsulation: bitstring = kemencap(Y_2,G_X_1) in
    {163}let G_Y_1: bitstring = kemcipher(encapsulation) in
    {178}let TH_2_1: bitstring = hash((G_Y_1,mess_1_hash_1)) in
    {164}let G_XY_2: bitstring = kemkey(encapsulation) in
    {179}let PRK_2e_1: bitstring = hkdfextract(TH_2_1,G_XY_2) in
    {183}let SALT_3e2m_1: bitstring = edhoc_kdf(PRK_2e_1,sthree,TH_2_1,hash_length) in
    {184}let PRK_3e2m_1: bitstring = hkdfextract(SALT_3e2m_1,K_AUTH_R_1) in
    {151}let cid_1: bitstring = computerId_1 in
    {188}event eDerivedR(cid_1,pkR_1,PRK_3e2m_1,Y_2,G_X_1);
    {189}event eTHRShared(pkR_1,TH_2_1);
    {190}event eDerivedRShared(pkR_1,G_XY_2);
    {191}event eDerivedIdR(ID_CRED_R_2,PRK_3e2m_1);
    {192}new encap_auth_random_seed: bitstring;
    {185}let MAC_2_1: bitstring = edhoc_kdf(PRK_3e2m_1,sfour,(ID_CRED_R_2,TH_2_1,pkR_1,EAD_2_1),hash_length) in
    {186}let SIGNATURE_or_MAC_2_1: bitstring = MAC_2_1 in
    {187}let plaintext_2_1: bitstring = (C_R_1,(ID_CRED_R_2,(SIGNATURE_or_MAC_2_1,EAD_2_1))) in
    {197}event eSendRData(method_four,pkR_1,(TH_1_1,TH_2_1,(suitesI_1,(EAD_1_1,(EAD_2_1,(m1_1,plaintext_1_1,plaintext_2_1))))));
    {182}let KEYSTREAM_2_1: bitstring = edhoc_kdf(PRK_2e_1,stwo,TH_2_1,plaintext_length) in
    {196}let m2_1: bitstring = (G_Y_1,encxor(plaintext_2_1,KEYSTREAM_2_1)) in
    {198}out(att, m2_1);
    {199}in(att, CIPHERTEXT_3_2: bitstring);
    {200}let TH_3_1: bitstring = hash((TH_2_1,(plaintext_2_1,pkR_1))) in
    {202}let IV_3_1: bitstring = edhoc_kdf(PRK_3e2m_1,ssix,TH_3_1,iv_length) in
    {201}let K_3_1: bitstring = edhoc_kdf(PRK_3e2m_1,sfive,TH_3_1,key_length) in
    {205}let plaintext_3_1: bitstring = aeaddec(CIPHERTEXT_3_2,K_3_1,IV_3_1) in
    {206}let (=ID_CRED_I_1,(SIGNATURE_or_MAC_3_1: bitstring,EAD_3_1: bitstring)) = plaintext_3_1 in
    {207}let pkI_3: bitstring = get_kem_auth(ID_CRED_I_1) in
    {203}let SALT_4e3m_1: bitstring = edhoc_kdf(PRK_3e2m_1,sseven,TH_3_1,hash_length) in
    {193}let encap_auth_I_2: bitstring = kemencap(encap_auth_random_seed,pkI_1) in
    {194}let K_AUTH_I_1: bitstring = kemkey(encap_auth_I_2) in
    {204}let PRK_4e3m_1: bitstring = hkdfextract(SALT_4e3m_1,K_AUTH_I_1) in
    {208}let MAC_3_1: bitstring = edhoc_kdf(PRK_4e3m_1,seight,(ID_CRED_I_1,TH_3_1,pkI_3,EAD_3_1),hash_length) in
    {209}if (SIGNATURE_or_MAC_3_1 = MAC_3_1) then
    {210}event eCheckedMAC3(ID_CRED_R_2,MAC_3_1);
    {211}let TH_4_1: bitstring = hash((TH_3_1,(plaintext_3_1,pkI_3))) in
    {212}let PRK_out_1: bitstring = edhoc_kdf(PRK_4e3m_1,snine,TH_4_1,hash_length) in
    {213}event eAcceptR(cid_1,method_four,pkI_3,pkR_1,PRK_3e2m_1,PRK_4e3m_1,PRK_out_1,Y_2,G_X_1);
    {214}event eSecretsR(cid_1,method_four,pkI_3,pkR_1,PRK_2e_1,PRK_3e2m_1,PRK_4e3m_1,PRK_out_1,KEYSTREAM_2_1,K_3_1,IV_3_1,Y_2,G_X_1);
    (
        {215}event eAcceptRData(PRK_out_1,method_four,pkI_3,pkR_1,Y_2,G_X_1,(TH_1_1,TH_2_1,(TH_3_1,(TH_4_1,(suitesI_1,(EAD_1_1,(EAD_2_1,(EAD_3_1,(m1_1,(plaintext_1_1,plaintext_2_1,plaintext_3_1))))))))))
    ) | (
        {216}event eLeakSessionKey(PRK_out_1);
        {217}out(att, PRK_out_1)
    )
) | (
    {218}!
    {223}in(att, (C_R_3: bitstring,(EAD_2_3: bitstring,suitesR: bitstring)));
    {224}in(att, m1_3: bitstring);
    {225}let (method_3: bitstring,suitesI_3: bitstring,G_X_3: bitstring,C_I_3: bitstring,CT_AUTH_R_3: bitstring,CIPHERTEXT_1_3: bitstring,EAD_1_3: bitstring) = m1_3 in
    {226}event eMethodOk(method_3);
    {227}new Y: bitstring;
    {228}event eShare(Y);
    {236}if (method_3 = method_four) then
    {238}let TH_1_3: bitstring = hash((G_X_3,CT_AUTH_R_3)) in
    {222}let sk_kem_authR: bitstring = sk_auth_kem_2 in
    {237}let K_AUTH_R_3: bitstring = kemdecap(CT_AUTH_R_3,sk_kem_authR) in
    {239}let PRK_1e_3: bitstring = hkdfextract(TH_1_3,K_AUTH_R_3) in
    {241}let IV_1_3: bitstring = edhoc_kdf(PRK_1e_3,sone,TH_1_3,iv_length) in
    {240}let K_1_3: bitstring = edhoc_kdf(PRK_1e_3,szero,TH_1_3,key_length) in
    {242}let plaintext_1_3: bitstring = aeaddec(CIPHERTEXT_1_3,K_1_3,IV_1_3) in
    {243}let ID_CRED_I_3: bitstring = plaintext_1_3 in
    {234}let KEM_CRED_R: bitstring = kempk(sk_kem_authR) in
    {220}let skR: bitstring = sk_2 in
    {233}let CRED_R: bitstring = pk(skR) in
    {221}let R_1: bitstring = ltdh_2 in
    {229}let G_R: bitstring = R_1 in
    {235}let ID_CRED_R: bitstring = id(CRED_R,G_R,KEM_CRED_R) in
    {244}if (ID_CRED_R ≠ ID_CRED_I_3) then
    {248}let pkR_3: bitstring = get_kem_auth(ID_CRED_R) in
    {249}let pkI_4: bitstring = get_kem_auth(ID_CRED_I_3) in
    {245}let mess_1_hash_3: bitstring = hash(m1_3) in
    {230}let encapsulation_1: bitstring = kemencap(Y,G_X_3) in
    {231}let G_Y_3: bitstring = kemcipher(encapsulation_1) in
    {246}let TH_2_3: bitstring = hash((G_Y_3,mess_1_hash_3)) in
    {232}let G_XY: bitstring = kemkey(encapsulation_1) in
    {247}let PRK_2e_3: bitstring = hkdfextract(TH_2_3,G_XY) in
    {251}let SALT_3e2m_3: bitstring = edhoc_kdf(PRK_2e_3,sthree,TH_2_3,hash_length) in
    {252}let PRK_3e2m_3: bitstring = hkdfextract(SALT_3e2m_3,K_AUTH_R_3) in
    {219}let cid_3: bitstring = computerId_2 in
    {256}event eDerivedR(cid_3,pkR_3,PRK_3e2m_3,Y,G_X_3);
    {257}event eTHRShared(pkR_3,TH_2_3);
    {258}event eDerivedRShared(pkR_3,G_XY);
    {259}event eDerivedIdR(ID_CRED_R,PRK_3e2m_3);
    {260}new encap_auth_random_seed_1: bitstring;
    {253}let MAC_2_3: bitstring = edhoc_kdf(PRK_3e2m_3,sfour,(ID_CRED_R,TH_2_3,pkR_3,EAD_2_3),hash_length) in
    {254}let SIGNATURE_or_MAC_2_3: bitstring = MAC_2_3 in
    {255}let plaintext_2_3: bitstring = (C_R_3,(ID_CRED_R,(SIGNATURE_or_MAC_2_3,EAD_2_3))) in
    {265}event eSendRData(method_four,pkR_3,(TH_1_3,TH_2_3,(suitesI_3,(EAD_1_3,(EAD_2_3,(m1_3,plaintext_1_3,plaintext_2_3))))));
    {250}let KEYSTREAM_2_3: bitstring = edhoc_kdf(PRK_2e_3,stwo,TH_2_3,plaintext_length) in
    {264}let m2_3: bitstring = (G_Y_3,encxor(plaintext_2_3,KEYSTREAM_2_3)) in
    {266}out(att, m2_3);
    {267}in(att, CIPHERTEXT_3: bitstring);
    {268}let TH_3_3: bitstring = hash((TH_2_3,(plaintext_2_3,pkR_3))) in
    {270}let IV_3_3: bitstring = edhoc_kdf(PRK_3e2m_3,ssix,TH_3_3,iv_length) in
    {269}let K_3_3: bitstring = edhoc_kdf(PRK_3e2m_3,sfive,TH_3_3,key_length) in
    {273}let plaintext_3_3: bitstring = aeaddec(CIPHERTEXT_3,K_3_3,IV_3_3) in
    {274}let (=ID_CRED_I_3,(SIGNATURE_or_MAC_3_3: bitstring,EAD_3_3: bitstring)) = plaintext_3_3 in
    {275}let pkI_5: bitstring = get_kem_auth(ID_CRED_I_3) in
    {271}let SALT_4e3m_3: bitstring = edhoc_kdf(PRK_3e2m_3,sseven,TH_3_3,hash_length) in
    {261}let encap_auth_I: bitstring = kemencap(encap_auth_random_seed_1,pkI_4) in
    {262}let K_AUTH_I_3: bitstring = kemkey(encap_auth_I) in
    {272}let PRK_4e3m_3: bitstring = hkdfextract(SALT_4e3m_3,K_AUTH_I_3) in
    {276}let MAC_3_3: bitstring = edhoc_kdf(PRK_4e3m_3,seight,(ID_CRED_I_3,TH_3_3,pkI_5,EAD_3_3),hash_length) in
    {277}if (SIGNATURE_or_MAC_3_3 = MAC_3_3) then
    {278}event eCheckedMAC3(ID_CRED_R,MAC_3_3);
    {279}let TH_4_3: bitstring = hash((TH_3_3,(plaintext_3_3,pkI_5))) in
    {280}let PRK_out_3: bitstring = edhoc_kdf(PRK_4e3m_3,snine,TH_4_3,hash_length) in
    {281}event eAcceptR(cid_3,method_four,pkI_5,pkR_3,PRK_3e2m_3,PRK_4e3m_3,PRK_out_3,Y,G_X_3);
    {282}event eSecretsR(cid_3,method_four,pkI_5,pkR_3,PRK_2e_3,PRK_3e2m_3,PRK_4e3m_3,PRK_out_3,KEYSTREAM_2_3,K_3_3,IV_3_3,Y,G_X_3);
    (
        {283}event eAcceptRData(PRK_out_3,method_four,pkI_5,pkR_3,Y,G_X_3,(TH_1_3,TH_2_3,(TH_3_3,(TH_4_3,(suitesI_3,(EAD_1_3,(EAD_2_3,(EAD_3_3,(m1_3,(plaintext_1_3,plaintext_2_3,plaintext_3_3))))))))))
    ) | (
        {284}event eLeakSessionKey(PRK_out_3);
        {285}out(att, PRK_out_3)
    )
) | (
    {286}!
    {291}in(att, (method_4: bitstring,(suitesI_4: bitstring,(C_I_4: bitstring,EAD_1_4: bitstring))));
    {292}event eMethodOk(method_4);
    {293}new X_1: bitstring;
    {294}new random_authR_2: bitstring;
    {295}new EAD_3_4: bitstring;
    {296}event eShare(X_1);
    {290}let sk_kem_authI_2: bitstring = choice[sk_auth_kem_1,sk_auth_kem_2] in
    {298}let KEM_CRED_I_1: bitstring = kempk(sk_kem_authI_2) in
    {288}let skI_1: bitstring = choice[sk_1,sk_2] in
    {297}let CRED_I_1: bitstring = pk(skI_1) in
    {289}let I_3: bitstring = choice[ltdh_1,ltdh_2] in
    {299}let ID_CRED_I_4: bitstring = id(CRED_I_1,I_3,KEM_CRED_I_1) in
    {300}if (ID_CRED_I_4 ≠ idd_2) then
    {301}if (method_4 = method_four) then
    {302}let pkR_4: bitstring = get_kem_auth(idd_2) in
    {307}let G_X_4: bitstring = kempk(X_1) in
    {313}let m1_4: bitstring = (method_4,suitesI_4,G_X_4,C_I_4,EAD_1_4) in
    {314}out(att, m1_4);
    {315}in(att, m2_4: bitstring);
    {316}let (G_Y_4: bitstring,CIPHERTEXT_2_1: bitstring,CT_AUTH_I_4: bitstring) = m2_4 in
    {319}let G_YX_1: bitstring = kemdecap(G_Y_4,X_1) in
    {317}let mess_1_hash_4: bitstring = hash(m1_4) in
    {318}let TH_2_4: bitstring = hash((G_Y_4,mess_1_hash_4)) in
    {320}let PRK_2e_4: bitstring = hkdfextract(TH_2_4,G_YX_1) in
    {321}let KEYSTREAM_2_4: bitstring = edhoc_kdf(PRK_2e_4,stwo,TH_2_4,plaintext_length) in
    {322}let plaintext_2_4: bitstring = decxor(CIPHERTEXT_2_1,KEYSTREAM_2_4) in
    {323}let (C_R_4: bitstring,=idd_2,SIGNATURE_or_MAC_2_4: bitstring,EAD_2_4: bitstring) = plaintext_2_4 in
    {324}let pkI_6: bitstring = get_kem_auth(ID_CRED_I_4) in
    {327}event eDerivedIShared(pkI_6,G_YX_1);
    {325}let SALT_3e2m_4: bitstring = edhoc_kdf(PRK_2e_4,sthree,TH_2_4,hash_length) in
    {303}let encap_auth_R_1: bitstring = kemencap(random_authR_2,pkR_4) in
    {304}let K_AUTH_R_4: bitstring = kemkey(encap_auth_R_1) in
    {326}let PRK_3e2m_4: bitstring = hkdfextract(SALT_3e2m_4,K_AUTH_R_4) in
    {328}let MAC_2_4: bitstring = edhoc_kdf(PRK_3e2m_4,sfour,(idd_2,TH_2_4,pkR_4,EAD_2_4),hash_length) in
    {329}if (SIGNATURE_or_MAC_2_4 = MAC_2_4) then
    {330}event eCheckedMAC2(ID_CRED_I_4,MAC_2_4);
    {331}let TH_3_4: bitstring = hash((TH_2_4,(plaintext_2_4,pkR_4))) in
    {332}event eTHIShared(pkI_6,TH_3_4);
    {336}let K_AUTH_I_4: bitstring = kemdecap(CT_AUTH_I_4,sk_kem_authI_2) in
    {335}let SALT_4e3m_4: bitstring = edhoc_kdf(PRK_3e2m_4,sseven,TH_3_4,hash_length) in
    {337}let PRK_4e3m_4: bitstring = hkdfextract(SALT_4e3m_4,K_AUTH_I_4) in
    {338}let MAC_3_4: bitstring = edhoc_kdf(PRK_4e3m_4,seight,(ID_CRED_I_4,TH_3_4,pkI_6,EAD_3_4),hash_length) in
    {339}let SIGNATURE_or_MAC_3_4: bitstring = MAC_3_4 in
    {340}let plaintext_3_4: bitstring = (ID_CRED_I_4,(SIGNATURE_or_MAC_3_4,EAD_3_4)) in
    {342}let TH_4_4: bitstring = hash((TH_3_4,(plaintext_3_4,pkI_6))) in
    {343}let PRK_out_4: bitstring = edhoc_kdf(PRK_4e3m_4,snine,TH_4_4,hash_length) in
    {287}let cid_4: bitstring = choice[computerId_1,computerId_2] in
    {344}event eAcceptI(cid_4,method_four,pkI_6,pkR_4,PRK_3e2m_4,PRK_4e3m_4,PRK_out_4,X_1,G_Y_4);
    {334}let IV_3_4: bitstring = edhoc_kdf(PRK_3e2m_4,ssix,TH_3_4,iv_length) in
    {333}let K_3_4: bitstring = edhoc_kdf(PRK_3e2m_4,sfive,TH_3_4,key_length) in
    {345}event eSecretsI(cid_4,method_four,pkI_6,pkR_4,PRK_2e_4,PRK_3e2m_4,PRK_4e3m_4,PRK_out_4,KEYSTREAM_2_4,K_3_4,IV_3_4,X_1,G_Y_4);
    {305}let CT_AUTH_R_4: bitstring = kemcipher(encap_auth_R_1) in
    {308}let TH_1_4: bitstring = hash((G_X_4,CT_AUTH_R_4)) in
    {306}let plaintext_1_4: bitstring = ID_CRED_I_4 in
    {346}event eAcceptIData(PRK_out_4,method_four,pkI_6,pkR_4,X_1,G_Y_4,(TH_1_4,TH_2_4,(TH_3_4,(TH_4_4,(suitesI_4,(EAD_1_4,(EAD_2_4,(EAD_3_4,(m1_4,(plaintext_1_4,plaintext_2_4,plaintext_3_4))))))))));
    (
        {341}let m3_1: bitstring = aeadenc(plaintext_3_4,srep,K_3_4,IV_3_4) in
        {347}out(att, m3_1)
    ) | (
        {348}event eLeakSessionKey(PRK_out_4);
        {349}out(att, PRK_out_4)
    )
) | (
    {350}phase 1;
    {351}event eCompromise(kempk(sk_auth_kem_1));
    {352}event eCompromise(kempk(sk_auth_kem_2));
    {353}out(att, sk_auth_kem_1);
    {354}out(att, sk_auth_kem_2)
)

Translating the process into Horn clauses...
Completing...
goal reachable: bad

Derivation:
Abbreviations:
@occ291_1 = @occ291[!2 = @sid,!1 = @sid_1]

1. The attacker has some term EAD_1_5 (resp. EAD_1_6).
attacker2(EAD_1_5,EAD_1_6).

2. The attacker has some term C_I_5 (resp. C_I_6).
attacker2(C_I_5,C_I_6).

3. By 2, the attacker may know C_I_5 (resp. C_I_6).
By 1, the attacker may know EAD_1_5 (resp. EAD_1_6).
Using the function 2-tuple the attacker may obtain (C_I_5,EAD_1_5) (resp. (C_I_6,EAD_1_6)).
attacker2((C_I_5,EAD_1_5),(C_I_6,EAD_1_6)).

4. The attacker has some term suitesI_5 (resp. suitesI_6).
attacker2(suitesI_5,suitesI_6).

5. By 4, the attacker may know suitesI_5 (resp. suitesI_6).
By 3, the attacker may know (C_I_5,EAD_1_5) (resp. (C_I_6,EAD_1_6)).
Using the function 2-tuple the attacker may obtain (suitesI_5,(C_I_5,EAD_1_5)) (resp. (suitesI_6,(C_I_6,EAD_1_6))).
attacker2((suitesI_5,(C_I_5,EAD_1_5)),(suitesI_6,(C_I_6,EAD_1_6))).

6. The attacker has some term method_5 (resp. method_6).
attacker2(method_5,method_6).

7. By 6, the attacker may know method_5 (resp. method_6).
By 5, the attacker may know (suitesI_5,(C_I_5,EAD_1_5)) (resp. (suitesI_6,(C_I_6,EAD_1_6))).
Using the function 2-tuple the attacker may obtain (method_5,(suitesI_5,(C_I_5,EAD_1_5))) (resp. (method_6,(suitesI_6,(C_I_6,EAD_1_6)))).
attacker2((method_5,(suitesI_5,(C_I_5,EAD_1_5))),(method_6,(suitesI_6,(C_I_6,EAD_1_6)))).

8. The event @p_act(@occ291_1,(method_5,(suitesI_5,(C_I_5,EAD_1_5)))) (resp. event @p_act(@occ291_1,(method_6,(suitesI_6,(C_I_6,EAD_1_6))))) records how variables are instantiated at {291}.
The message (method_5,(suitesI_5,(C_I_5,EAD_1_5))) (resp. (method_6,(suitesI_6,(C_I_6,EAD_1_6)))) that the attacker may have by 7 may be received at input {291}.
So the attacker can make a distinguishing test at {300}.
bad.


Unified EAD_1_5 with EAD_1_6
Unified C_I_5 with C_I_6
Unified suitesI_5 with suitesI_6
Unified method_5 with method_6
A more detailed output of the traces is available with
  set traceDisplay = long.

new computerId_1: bitstring creating computerId at {2} in copy a

new sk_1: bitstring creating sk at {3} in copy a

new sk_auth_kem_1: bitstring creating sk_auth_kem at {4} in copy a

new ltdh_1: bitstring creating ltdh at {5} in copy a

out(att, (~M,(~M_1,~M_2,~M_3))) with ~M = id(pk(sk),ltdh,kempk(sk_auth_kem)), ~M_1 = pk(sk), ~M_2 = ltdh, ~M_3 = kempk(sk_auth_kem) at {7} in copy a

event eShareLT(ltdh) at {8} in copy a

event eHonest(pk(sk)) at {9} in copy a

event eHonest(kempk(sk_auth_kem)) at {10} in copy a

new sk_2: bitstring creating sk_3 at {11} in copy a

new sk_auth_kem_2: bitstring creating sk_auth_kem_3 at {12} in copy a

new ltdh_2: bitstring creating ltdh_3 at {13} in copy a

new computerId_2: bitstring creating computerId_3 at {14} in copy a

out(att, (~M_4,(~M_5,~M_6,~M_7))) with ~M_4 = id(pk(sk_3),ltdh_3,kempk(sk_auth_kem_3)), ~M_5 = pk(sk_3), ~M_6 = ltdh_3, ~M_7 = kempk(sk_auth_kem_3) at {16} in copy a

event eShareLT(ltdh_3) at {17} in copy a

event eHonest(pk(sk_3)) at {18} in copy a

event eHonest(kempk(sk_auth_kem_3)) at {19} in copy a

in(att, (a_1,(a_2,(a_3,a_4)))) at {291} in copy a, a_5

event eMethodOk(a_1) at {292} in copy a, a_5

new X_1: bitstring creating X_3 at {293} in copy a, a_5

new random_authR_2: bitstring creating random_authR_3 at {294} in copy a, a_5

new EAD_3_4: bitstring creating EAD at {295} in copy a, a_5

event eShare(X_3) at {296} in copy a, a_5

A process performs a test that may succeed on one side and not on the other at {300} in copy a, a_5.
A trace has been found.
RESULT Observational equivalence cannot be proved.
Looking for simplified processes ...
