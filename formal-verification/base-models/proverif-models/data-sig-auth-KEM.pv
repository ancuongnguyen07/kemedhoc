free att:channel.
free sComp:bitstring.
free sSignature1:bitstring.
free sSignature2:bitstring.
free sfour:bitstring.
free srep:bitstring.
free sseven:bitstring.
free ssix:bitstring.
free sthree:bitstring.
free stwo:bitstring.
free stzero:bitstring.
fun aeadenc(bitstring,bitstring,bitstring,bitstring):bitstring.
fun aeadmalleable(bitstring,bitstring):bitstring.
fun const_cred():bitstring.
fun const_grp():bitstring.
fun edhoc_kdf(bitstring,bitstring,bitstring,bitstring):bitstring.
fun edhoc_mac_length():bitstring.
fun encxor(bitstring,bitstring):bitstring.
fun error_code_one():bitstring.
fun error_code_two():bitstring.
fun fst(bitstring):bitstring.
fun grpid():bitstring.
fun hash(bitstring):bitstring.
fun hash_length():bitstring.
fun hkdfexpand(bitstring,bitstring):bitstring.
fun hkdfextract(bitstring,bitstring):bitstring.
fun id(bitstring,bitstring):bitstring.
fun iv_length():bitstring.
fun kemdecap(bitstring,bitstring):bitstring.
fun kemencap(bitstring,bitstring):bitstring.
fun kemkey(bitstring,bitstring):bitstring.
fun kempk(bitstring):bitstring.
fun key_length():bitstring.
fun length():bitstring.
fun method_one():bitstring.
fun method_three():bitstring.
fun method_two():bitstring.
fun method_zero():bitstring.
fun pair(bitstring,bitstring):bitstring.
fun pk(bitstring):bitstring.
fun plaintext_length():bitstring.
fun sign(bitstring,bitstring,bitstring):bitstring.
fun sigtrue():bitstring.
fun snd(bitstring):bitstring.
fun suitesIConst():bitstring.
fun suitesRConst():bitstring.
fun weakcap():bitstring.
fun weakkem():bitstring.
fun weaksec():bitstring.
fun wrap(bitstring):bitstring.
event eAcceptI(bitstring,bitstring,bitstring,bitstring,bitstring,bitstring,bitstring,bitstring,bitstring).
event eAcceptIData(bitstring,bitstring,bitstring,bitstring,bitstring,bitstring,bitstring).
event eAcceptR(bitstring,bitstring,bitstring,bitstring,bitstring,bitstring,bitstring,bitstring).
event eAcceptRData(bitstring,bitstring,bitstring,bitstring,bitstring,bitstring,bitstring).
event eCompromise(bitstring).
event eDerivedIShared(bitstring,bitstring).
event eDerivedIdR(bitstring,bitstring).
event eDerivedR(bitstring,bitstring,bitstring,bitstring,bitstring).
event eDerivedRShared(bitstring,bitstring).
event eHonest(bitstring).
event eLeak(bitstring).
event eLeakSessionKey(bitstring).
event eLeakShare(bitstring).
event eMethodOk(bitstring).
event eSecretsI(bitstring,bitstring,bitstring,bitstring,bitstring,bitstring,bitstring,bitstring,bitstring,bitstring,bitstring,bitstring,bitstring).
event eSecretsR(bitstring,bitstring,bitstring,bitstring,bitstring,bitstring,bitstring,bitstring,bitstring,bitstring,bitstring,bitstring,bitstring).
event eSendRData(bitstring,bitstring,bitstring).
event eShare(bitstring).
event eShareLT(bitstring).
event eTHIShared(bitstring,bitstring).
event eTHRShared(bitstring,bitstring).
equation forall aa:bitstring, k:bitstring, m:bitstring, r:bitstring, r2:bitstring;   aeadmalleable(aeadenc(m, r, k, aa), r2) = aeadenc(m, r2, k, aa).
equation forall n:bitstring, s:bitstring;   kemdecap(kemencap(n, kempk(s)), s) = n.
equation forall s:bitstring;   kemdecap(weakkem, s) = weakkem.
equation forall x:bitstring;   kemkey(x, kempk(weakkem)) = weakkem.
equation forall x_1:bitstring, x_2:bitstring;   fst((x_1, x_2)) = x_1.
equation forall x_1:bitstring, x_2:bitstring;   snd((x_1, x_2)) = x_2.
reduc forall ad:bitstring, k:bitstring, m:bitstring, r:bitstring;   aeaddec(aeadenc(m, r, k, ad), k, ad) = m.
reduc forall m:bitstring, r:bitstring, sk:bitstring;   revealsign(sign(m, r, sk)) = m.
reduc forall m:bitstring, r:bitstring, sk:bitstring;   verify(sign(m, r, sk), m, pk(sk)) = sigtrue.
reduc forall m:bitstring, x:bitstring;   decxor(encxor(m, x), x) = m.
reduc forall x:bitstring, y:bitstring;   get_DH_cred(id(x, y)) = y.
reduc forall x:bitstring, y:bitstring;   get_sig_cred(id(x, y)) = x.
reduc forall x:bitstring;   check_cred(x) = const_cred.
reduc forall x:bitstring;   check_grp(x) = const_grp.
set preciseActions=true.

axiom k:bitstring; event(eShare( k )) && attacker( k ) ==> event(eLeakShare(k)).
axiom k:bitstring; event(eShareLT( k )) && attacker( k ) ==> event(eLeak(k)).

(*data_authentication_I_to_R*)
query EAD_1:bitstring, EAD_2:bitstring, EAD_3:bitstring,
      PRK_out:bitstring, TH_2:bitstring, TH_3:bitstring, TH_4:bitstring,
      gy:bitstring, m1:bitstring, method:bitstring, p2:bitstring, p3:bitstring,
      pkI:bitstring, pkR:bitstring, suitesI:bitstring, x:bitstring, i:time,
      j:time, l:time;
 ((event(eAcceptIData( PRK_out, method, pkI, pkR, x, gy,
                       (TH_2, (TH_3, (TH_4, (suitesI, (EAD_1, (EAD_2, (EAD_3, (m1, (p2, p3)))))))))
         ))@i) &&
  (event(eHonest( pkR ))@j)) ==>
 ((((l < i) &&
    (event(eSendRData( method, pkR,
                       (TH_2, (suitesI, (EAD_1, (EAD_2, (m1, p2)))))
           ))@l)) ||
   ((l < i) && (event(eCompromise( pkR ))@l))) ||
  ((event(eLeakShare( x ))@l) &&
   ((method = method_two) || (method = method_three))))
.
let MakeDEO()=
    0.
let ContactJudgeFromI(ID_CRED_R_2:bitstring, TH_2J_2:bitstring,
                      pkR_2:bitstring, EAD_2_2:bitstring, MAC_2J_2:bitstring,
                      SIGNATURE_or_MAC_2_2:bitstring)=
    0.
let ContactJudgeFromR(ID_CRED_I_2:bitstring, TH_3J_2:bitstring,
                      pkI_2:bitstring, EAD_3_2:bitstring, MAC_3J_2:bitstring,
                      SIGNATURE_or_MAC_3_2:bitstring)=
    0.
let CompromiseShare(s_2:bitstring)=
    event eLeakShare( s_2 );
    event eLeakShare( kempk(s_2) );
    out(att,s_2).
let leakSKey(key_2:bitstring)=
    event eLeakSessionKey( key_2 );
    out(att,key_2).
let JudgeR()=
    0.
let JudgeI()=
    0.
let I(cid_2:bitstring, skI_2:bitstring, I_2:bitstring,
      ID_CRED_R_2:bitstring)=
    in(att,(method_2:bitstring, (suitesI_2:bitstring, (C_I_2:bitstring, EAD_1_2:bitstring))));
    event eMethodOk( method_2 );
    new X_2:bitstring;
    new EAD_3_2:bitstring;
    event eShare( X_2 );
    ((CompromiseShare(X_2))
   | (let CRED_I_2:bitstring=pk(skI_2) in
      let ID_CRED_I_2:bitstring=id(CRED_I_2, I_2) in
      let G_X_2:bitstring=kempk(X_2) in
      let m1_2:bitstring=(method_2, (suitesI_2, (G_X_2, (C_I_2, EAD_1_2)))) in
      out(att,m1_2);
      in(att,m2_2:bitstring);
      let (G_Y_2:bitstring, CIPHERTEXT_2_2:bitstring)=m2_2 in
      let TH_1_2:bitstring=hash((wrap(method_2), (wrap(suitesI_2), (wrap(G_X_2), (wrap(C_I_2), EAD_1_2))))) in
      let TH_2_2:bitstring=hash((wrap(G_Y_2), wrap(TH_1_2))) in
      let G_YX_2:bitstring=kemdecap(G_Y_2, X_2) in
      let PRK_2e_2:bitstring=hkdfextract(TH_2_2, G_YX_2) in
      let KEYSTREAM_2_2:bitstring=edhoc_kdf(PRK_2e_2, stzero, TH_2_2,
                                            plaintext_length) in
      let plaintext_2_2:bitstring=decxor(CIPHERTEXT_2_2, KEYSTREAM_2_2) in
      let (C_R_2:bitstring, (=ID_CRED_R_2, (SIGNATURE_or_MAC_2_2:bitstring, EAD_2_2:bitstring)))=plaintext_2_2 in
      if check_grp(G_Y_2) = grpid then
          (0)
      else
          (if ID_CRED_I_2 = check_cred(ID_CRED_R_2) then
               (0)
           else
               (if method_2 = method_zero then
                    (let pkR_2:bitstring=get_sig_cred(ID_CRED_R_2) in
                     let pkI_2:bitstring=get_sig_cred(ID_CRED_I_2) in
                     let PRK_3e2m_2:bitstring=PRK_2e_2 in
                     event eDerivedIShared( pkI_2, G_YX_2 );
                     let MAC_2_2:bitstring=edhoc_kdf(PRK_3e2m_2, stwo,
                                                     (ID_CRED_R_2, (TH_2_2, (pkR_2, EAD_2_2))),
                                                     hash_length) in
                     if verify(SIGNATURE_or_MAC_2_2,
                               (sSignature1, (ID_CRED_R_2, (TH_2_2, (pkR_2, (EAD_2_2, MAC_2_2))))),
                               pkR_2) =
                        sigtrue then
                         (let TH_3_2:bitstring=hash((wrap(TH_2_2), (plaintext_2_2, pkR_2))) in
                          event eTHIShared( pkI_2, TH_3_2 );
                          let PRK_4e3m_2:bitstring=PRK_3e2m_2 in
                          let MAC_3_2:bitstring=edhoc_kdf(PRK_4e3m_2, ssix,
                                                          (ID_CRED_I_2, (TH_3_2, (pkI_2, EAD_3_2))),
                                                          hash_length) in
                          let SIGNATURE_or_MAC_3_2:bitstring=sign((sSignature2, (ID_CRED_I_2, (TH_3_2, (pkI_2, (EAD_3_2, MAC_3_2))))),
                                                                  srep, skI_2) in
                          let K_3_2:bitstring=edhoc_kdf(PRK_3e2m_2, sthree, TH_3_2, key_length) in
                          let IV_3_2:bitstring=edhoc_kdf(PRK_3e2m_2, sfour, TH_3_2, iv_length) in
                          let plaintext_3_2:bitstring=(ID_CRED_I_2, (SIGNATURE_or_MAC_3_2, EAD_3_2)) in
                          let m3_2:bitstring=aeadenc(plaintext_3_2, srep, K_3_2, IV_3_2) in
                          let TH_4_2:bitstring=hash((wrap(TH_3_2), (plaintext_3_2, pkI_2))) in
                          let PRK_out_2:bitstring=edhoc_kdf(PRK_4e3m_2, sseven, TH_4_2,
                                                            hash_length) in
                          event eAcceptI( cid_2, method_zero, pkI_2, pkR_2, PRK_3e2m_2, PRK_4e3m_2,
                                          PRK_out_2, X_2, G_Y_2
                                );
                          event eSecretsI( cid_2, method_zero, pkI_2, pkR_2, PRK_2e_2, PRK_3e2m_2,
                                           PRK_4e3m_2, PRK_out_2, KEYSTREAM_2_2, K_3_2, IV_3_2, X_2, G_Y_2
                                );
                          event eAcceptIData( PRK_out_2, method_zero, pkI_2, pkR_2, X_2, G_Y_2,
                                              (TH_2_2, (TH_3_2, (TH_4_2, (suitesI_2, (EAD_1_2, (EAD_2_2, (EAD_3_2, (m1_2, (plaintext_2_2, plaintext_3_2)))))))))
                                );
                          out(att,m3_2);
                          ((ContactJudgeFromI(ID_CRED_R_2, TH_2_2, pkR_2, EAD_2_2, MAC_2_2,
                                              SIGNATURE_or_MAC_2_2))
                         | (leakSKey(PRK_out_2))))))))).
let CompromiseKEMencap(s_2:bitstring, encap_2:bitstring)=
    event eLeakShare( s_2 );
    event eLeakShare( encap_2 );
    out(att,s_2).
let R(cid_2:bitstring, skR_2:bitstring, R_2:bitstring)=
    in(att,(C_R_2:bitstring, (EAD_2_2:bitstring, suitesR_2:bitstring)));
    in(att,(method_2:bitstring, (suitesI_2:bitstring, (G_X_2:bitstring, (C_I_2:bitstring, EAD_1_2:bitstring)))));
    event eMethodOk( method_2 );
    let m1_2:bitstring=(method_2, (suitesI_2, (G_X_2, (C_I_2, EAD_1_2)))) in
    new Y_2:bitstring;
    event eShare( Y_2 );
    let G_R_2:bitstring=R_2 in
    let G_XY_2:bitstring=kemkey(Y_2, G_X_2) in
    let G_Y_2:bitstring=kemencap(G_XY_2, G_X_2) in
    ((CompromiseKEMencap(Y_2, G_Y_2))
   | (let CRED_R_2:bitstring=pk(skR_2) in
      let ID_CRED_R_2:bitstring=id(CRED_R_2, G_R_2) in
      let TH_1_2:bitstring=hash((wrap(method_2), (wrap(suitesI_2), (wrap(G_X_2), (wrap(C_I_2), EAD_1_2))))) in
      let TH_2_2:bitstring=hash((wrap(G_Y_2), wrap(TH_1_2))) in
      let PRK_2e_2:bitstring=hkdfextract(TH_2_2, G_XY_2) in
      if check_grp(G_X_2) = grpid then
          (0)
      else
          (if method_2 = method_zero then
               (let pkR_2:bitstring=get_sig_cred(ID_CRED_R_2) in
                let PRK_3e2m_2:bitstring=PRK_2e_2 in
                let MAC_2_2:bitstring=edhoc_kdf(PRK_3e2m_2, stwo,
                                                (ID_CRED_R_2, (TH_2_2, (pkR_2, EAD_2_2))), hash_length) in
                let SIGNATURE_or_MAC_2_2:bitstring=sign((sSignature1, (ID_CRED_R_2, (TH_2_2, (pkR_2, (EAD_2_2, MAC_2_2))))),
                                                        srep, skR_2) in
                let plaintext_2_2:bitstring=(C_R_2, (ID_CRED_R_2, (SIGNATURE_or_MAC_2_2, EAD_2_2))) in
                let KEYSTREAM_2_2:bitstring=edhoc_kdf(PRK_2e_2, stzero, TH_2_2,
                                                      plaintext_length) in
                event eDerivedR( cid_2, pkR_2, PRK_3e2m_2, Y_2, G_X_2 );
                event eTHRShared( pkR_2, TH_2_2 );
                event eDerivedRShared( pkR_2, G_XY_2 );
                event eDerivedIdR( ID_CRED_R_2, PRK_3e2m_2 );
                let m2_2:bitstring=(G_Y_2, (encxor(plaintext_2_2,
                                                   KEYSTREAM_2_2), C_R_2)) in
                event eSendRData( method_zero, pkR_2,
                                  (TH_2_2, (suitesI_2, (EAD_1_2, (EAD_2_2, (m1_2, plaintext_2_2)))))
                      );
                out(att,m2_2);
                in(att,CIPHERTEXT_3_2:bitstring);
                let TH_3_2:bitstring=hash((wrap(TH_2_2), (plaintext_2_2, pkR_2))) in
                let K_3_2:bitstring=edhoc_kdf(PRK_3e2m_2, sthree, TH_3_2, key_length) in
                let IV_3_2:bitstring=edhoc_kdf(PRK_3e2m_2, sfour, TH_3_2, iv_length) in
                let plaintext_3_2:bitstring=aeaddec(CIPHERTEXT_3_2, K_3_2, IV_3_2) in
                let (ID_CRED_I_2:bitstring, (SIGNATURE_or_MAC_3_2:bitstring, EAD_3_2:bitstring))=plaintext_3_2 in
                let pkI_2:bitstring=get_sig_cred(ID_CRED_I_2) in
                let TH_4_2:bitstring=hash((wrap(TH_3_2), (plaintext_3_2, pkI_2))) in
                let PRK_4e3m_2:bitstring=PRK_3e2m_2 in
                let MAC_3_2:bitstring=edhoc_kdf(PRK_4e3m_2, ssix,
                                                (ID_CRED_I_2, (TH_3_2, (pkI_2, EAD_3_2))), hash_length) in
                if verify(SIGNATURE_or_MAC_3_2,
                          (sSignature2, (ID_CRED_I_2, (TH_3_2, (pkI_2, (EAD_3_2, MAC_3_2))))),
                          pkI_2) =
                   sigtrue then
                    (if ID_CRED_R_2 = check_cred(ID_CRED_I_2) then
                         (0)
                     else
                         (let PRK_out_2:bitstring=edhoc_kdf(PRK_4e3m_2, sseven, TH_4_2,
                                                            hash_length) in
                          event eAcceptR( cid_2, method_zero, pkI_2, pkR_2, PRK_4e3m_2, PRK_out_2,
                                          Y_2, G_X_2
                                );
                          event eSecretsR( cid_2, method_zero, pkI_2, pkR_2, PRK_2e_2, PRK_3e2m_2,
                                           PRK_4e3m_2, PRK_out_2, KEYSTREAM_2_2, K_3_2, IV_3_2, Y_2, G_X_2
                                );
                          event eAcceptRData( PRK_out_2, method_zero, pkI_2, pkR_2, Y_2, G_X_2,
                                              (TH_2_2, (TH_3_2, (TH_4_2, (suitesI_2, (EAD_1_2, (EAD_2_2, (EAD_3_2, (m1_2, (plaintext_2_2, plaintext_3_2)))))))))
                                );
                          ((ContactJudgeFromR(ID_CRED_I_2, TH_3_2, pkI_2, EAD_3_2, MAC_3_2,
                                              SIGNATURE_or_MAC_3_2))
                         | (leakSKey(PRK_out_2))))))))).
let compromise(sk_2:bitstring)=
    in(att,=sComp);
    event eCompromise( pk(sk_2) );
    out(att,sk_2).
let compromiseDH(k_2:bitstring)=
    in(att,=sComp);
    event eCompromise( k_2 );
    event eLeak( k_2 );
    out(att,k_2).


process
    ((((((!
          (0))
       | (!
          (0))))
     | (!
        (0))))
   | (!
      (new sk_2:bitstring;
       new ltdh_2:bitstring;
       new computerId_2:bitstring;
       let idd_2:bitstring=id(pk(sk_2), ltdh_2) in
       out(att,(idd_2, (pk(sk_2), ltdh_2)));
       event eShareLT( ltdh_2 );
       event eHonest( pk(sk_2) );
       event eHonest( ltdh_2 );
       ((((((!
             (in(att,cred_2:bitstring);
              I(computerId_2, sk_2, ltdh_2, cred_2)))
          | (!
             (R(computerId_2, sk_2, ltdh_2)))))
        | (compromise(sk_2))))
      | (compromiseDH(ltdh_2))))))

(*
WARNING: the following wellformedness checks failed!

Inexistant lemma actions
========================

  lemma `secretR' references action 
    fact "AcceptR" (arity 8, Linear) 
  but no rule has such an action.
  
  lemma `secretR' references action 
    fact "Compromise" (arity 1, Linear) 
  but no rule has such an action.
  
  lemma `secretR' references action 
    fact "Honest" (arity 1, Linear) 
  but no rule has such an action.
  
  lemma `secretR' references action 
    fact "LeakSessionKey" (arity 1, Linear) 
  but no rule has such an action.
  
  lemma `secretR' references action 
    fact "LeakShare" (arity 1, Linear) 
  but no rule has such an action.
  
  lemma `secretR' references action 
    fact "LeakShare" (arity 1, Linear) 
  but no rule has such an action.
  
  lemma `secretI' references action 
    fact "AcceptI" (arity 9, Linear) 
  but no rule has such an action.
  
  lemma `secretI' references action 
    fact "Compromise" (arity 1, Linear) 
  but no rule has such an action.
  
  lemma `secretI' references action 
    fact "Honest" (arity 1, Linear) 
  but no rule has such an action.
  
  lemma `secretI' references action 
    fact "LeakSessionKey" (arity 1, Linear) 
  but no rule has such an action.
  
  lemma `secretI' references action 
    fact "LeakShare" (arity 1, Linear) 
  but no rule has such an action.
  
  lemma `secretI' references action 
    fact "LeakShare" (arity 1, Linear) 
  but no rule has such an action.
  
  lemma `honestauthRI_non_inj' references action 
    fact "AcceptI" (arity 9, Linear) 
  but no rule has such an action.
  
  lemma `honestauthRI_non_inj' references action 
    fact "AcceptR" (arity 8, Linear) 
  but no rule has such an action.
  
  lemma `honestauthRI_non_inj' references action 
    fact "Compromise" (arity 1, Linear) 
  but no rule has such an action.
  
  lemma `honestauthRI_non_inj' references action 
    fact "Honest" (arity 1, Linear) 
  but no rule has such an action.
  
  lemma `honestauthRI_non_inj' references action 
    fact "LeakShare" (arity 1, Linear) 
  but no rule has such an action.
  
  lemma `honestauthRI_unique' references action 
    fact "AcceptR" (arity 8, Linear) 
  but no rule has such an action.
  
  lemma `honestauthRI_unique' references action 
    fact "Compromise" (arity 1, Linear) 
  but no rule has such an action.
  
  lemma `honestauthRI_unique' references action 
    fact "Honest" (arity 1, Linear) 
  but no rule has such an action.
  
  lemma `honestauthRI_unique' references action 
    fact "Honest" (arity 1, Linear) 
  but no rule has such an action.
  
  lemma `honestauthRI_unique' references action 
    fact "LeakShare" (arity 1, Linear) 
  but no rule has such an action.
  
  lemma `honestauthIR_non_inj' references action 
    fact "AcceptI" (arity 9, Linear) 
  but no rule has such an action.
  
  lemma `honestauthIR_non_inj' references action 
    fact "Compromise" (arity 1, Linear) 
  but no rule has such an action.
  
  lemma `honestauthIR_non_inj' references action 
    fact "DerivedR" (arity 5, Linear) 
  but no rule has such an action.
  
  lemma `honestauthIR_non_inj' references action 
    fact "Honest" (arity 1, Linear) 
  but no rule has such an action.
  
  lemma `honestauthIR_non_inj' references action 
    fact "LeakShare" (arity 1, Linear) 
  but no rule has such an action.
  
  lemma `honestauthIR_unique' references action 
    fact "AcceptI" (arity 9, Linear) 
  but no rule has such an action.
  
  lemma `honestauthIR_unique' references action 
    fact "Compromise" (arity 1, Linear) 
  but no rule has such an action.
  
  lemma `honestauthIR_unique' references action 
    fact "Honest" (arity 1, Linear) 
  but no rule has such an action.
  
  lemma `honestauthIR_unique' references action 
    fact "Honest" (arity 1, Linear) 
  but no rule has such an action.
  
  lemma `honestauthIR_unique' references action 
    fact "LeakShare" (arity 1, Linear) 
  but no rule has such an action.
  
  lemma `data_authentication_I_to_R' references action 
    fact "AcceptIData" (arity 7, Linear) 
  but no rule has such an action.
  
  lemma `data_authentication_I_to_R' references action 
    fact "Compromise" (arity 1, Linear) 
  but no rule has such an action.
  
  lemma `data_authentication_I_to_R' references action 
    fact "Honest" (arity 1, Linear) 
  but no rule has such an action.
  
  lemma `data_authentication_I_to_R' references action 
    fact "LeakShare" (arity 1, Linear) 
  but no rule has such an action.
  
  lemma `data_authentication_I_to_R' references action 
    fact "SendRData" (arity 3, Linear) 
  but no rule has such an action.
  
  lemma `data_authentication_R_to_I' references action 
    fact "AcceptIData" (arity 7, Linear) 
  but no rule has such an action.
  
  lemma `data_authentication_R_to_I' references action 
    fact "AcceptRData" (arity 7, Linear) 
  but no rule has such an action.
  
  lemma `data_authentication_R_to_I' references action 
    fact "Compromise" (arity 1, Linear) 
  but no rule has such an action.
  
  lemma `data_authentication_R_to_I' references action 
    fact "Honest" (arity 1, Linear) 
  but no rule has such an action.
  
  lemma `data_authentication_R_to_I' references action 
    fact "LeakShare" (arity 1, Linear) 
  but no rule has such an action.
  
  lemma `authRI_unique' references action 
    fact "AcceptR" (arity 8, Linear) 
  but no rule has such an action.
  
  lemma `authRI_unique' references action 
    fact "AcceptR" (arity 8, Linear) 
  but no rule has such an action.
  
  lemma `authIR_unique' references action 
    fact "AcceptI" (arity 9, Linear) 
  but no rule has such an action.
  
  lemma `authIR_unique' references action 
    fact "AcceptI" (arity 9, Linear) 
  but no rule has such an action.

Subterm Convergence Warning
===========================

  User-defined equations must be convergent and have the finite variant property. The following equations are not subterm convergent. If you are sure that the set of equations is nevertheless convergent and has the finite variant property, you can ignore this warning and continue 

    aeadmalleable(aeadenc(m, r, k, aa), r2) = aeadenc(m, r2, k, aa)
   
 For more information, please refer to the manual : https://tamarin-prover.com/manual/master/book/010_modeling-issues.html 
*)

(*
Generated from:
Tamarin version 1.10.0
Maude version 2.7.1
Git revision: UNKNOWN, branch: UNKNOWN
Compiled at: 2024-10-30 14:56:23.355649243 UTC
*)

(*
WARNING: the following wellformedness checks failed!

Inexistant lemma actions
========================

  lemma `secretR' references action 
    fact "AcceptR" (arity 8, Linear) 
  but no rule has such an action.
  
  lemma `secretR' references action 
    fact "Compromise" (arity 1, Linear) 
  but no rule has such an action.
  
  lemma `secretR' references action 
    fact "Honest" (arity 1, Linear) 
  but no rule has such an action.
  
  lemma `secretR' references action 
    fact "LeakSessionKey" (arity 1, Linear) 
  but no rule has such an action.
  
  lemma `secretR' references action 
    fact "LeakShare" (arity 1, Linear) 
  but no rule has such an action.
  
  lemma `secretR' references action 
    fact "LeakShare" (arity 1, Linear) 
  but no rule has such an action.
  
  lemma `secretI' references action 
    fact "AcceptI" (arity 9, Linear) 
  but no rule has such an action.
  
  lemma `secretI' references action 
    fact "Compromise" (arity 1, Linear) 
  but no rule has such an action.
  
  lemma `secretI' references action 
    fact "Honest" (arity 1, Linear) 
  but no rule has such an action.
  
  lemma `secretI' references action 
    fact "LeakSessionKey" (arity 1, Linear) 
  but no rule has such an action.
  
  lemma `secretI' references action 
    fact "LeakShare" (arity 1, Linear) 
  but no rule has such an action.
  
  lemma `secretI' references action 
    fact "LeakShare" (arity 1, Linear) 
  but no rule has such an action.
  
  lemma `honestauthRI_non_inj' references action 
    fact "AcceptI" (arity 9, Linear) 
  but no rule has such an action.
  
  lemma `honestauthRI_non_inj' references action 
    fact "AcceptR" (arity 8, Linear) 
  but no rule has such an action.
  
  lemma `honestauthRI_non_inj' references action 
    fact "Compromise" (arity 1, Linear) 
  but no rule has such an action.
  
  lemma `honestauthRI_non_inj' references action 
    fact "Honest" (arity 1, Linear) 
  but no rule has such an action.
  
  lemma `honestauthRI_non_inj' references action 
    fact "LeakShare" (arity 1, Linear) 
  but no rule has such an action.
  
  lemma `honestauthRI_unique' references action 
    fact "AcceptR" (arity 8, Linear) 
  but no rule has such an action.
  
  lemma `honestauthRI_unique' references action 
    fact "Compromise" (arity 1, Linear) 
  but no rule has such an action.
  
  lemma `honestauthRI_unique' references action 
    fact "Honest" (arity 1, Linear) 
  but no rule has such an action.
  
  lemma `honestauthRI_unique' references action 
    fact "Honest" (arity 1, Linear) 
  but no rule has such an action.
  
  lemma `honestauthRI_unique' references action 
    fact "LeakShare" (arity 1, Linear) 
  but no rule has such an action.
  
  lemma `honestauthIR_non_inj' references action 
    fact "AcceptI" (arity 9, Linear) 
  but no rule has such an action.
  
  lemma `honestauthIR_non_inj' references action 
    fact "Compromise" (arity 1, Linear) 
  but no rule has such an action.
  
  lemma `honestauthIR_non_inj' references action 
    fact "DerivedR" (arity 5, Linear) 
  but no rule has such an action.
  
  lemma `honestauthIR_non_inj' references action 
    fact "Honest" (arity 1, Linear) 
  but no rule has such an action.
  
  lemma `honestauthIR_non_inj' references action 
    fact "LeakShare" (arity 1, Linear) 
  but no rule has such an action.
  
  lemma `honestauthIR_unique' references action 
    fact "AcceptI" (arity 9, Linear) 
  but no rule has such an action.
  
  lemma `honestauthIR_unique' references action 
    fact "Compromise" (arity 1, Linear) 
  but no rule has such an action.
  
  lemma `honestauthIR_unique' references action 
    fact "Honest" (arity 1, Linear) 
  but no rule has such an action.
  
  lemma `honestauthIR_unique' references action 
    fact "Honest" (arity 1, Linear) 
  but no rule has such an action.
  
  lemma `honestauthIR_unique' references action 
    fact "LeakShare" (arity 1, Linear) 
  but no rule has such an action.
  
  lemma `data_authentication_I_to_R' references action 
    fact "AcceptIData" (arity 7, Linear) 
  but no rule has such an action.
  
  lemma `data_authentication_I_to_R' references action 
    fact "Compromise" (arity 1, Linear) 
  but no rule has such an action.
  
  lemma `data_authentication_I_to_R' references action 
    fact "Honest" (arity 1, Linear) 
  but no rule has such an action.
  
  lemma `data_authentication_I_to_R' references action 
    fact "LeakShare" (arity 1, Linear) 
  but no rule has such an action.
  
  lemma `data_authentication_I_to_R' references action 
    fact "SendRData" (arity 3, Linear) 
  but no rule has such an action.
  
  lemma `data_authentication_R_to_I' references action 
    fact "AcceptIData" (arity 7, Linear) 
  but no rule has such an action.
  
  lemma `data_authentication_R_to_I' references action 
    fact "AcceptRData" (arity 7, Linear) 
  but no rule has such an action.
  
  lemma `data_authentication_R_to_I' references action 
    fact "Compromise" (arity 1, Linear) 
  but no rule has such an action.
  
  lemma `data_authentication_R_to_I' references action 
    fact "Honest" (arity 1, Linear) 
  but no rule has such an action.
  
  lemma `data_authentication_R_to_I' references action 
    fact "LeakShare" (arity 1, Linear) 
  but no rule has such an action.
  
  lemma `authRI_unique' references action 
    fact "AcceptR" (arity 8, Linear) 
  but no rule has such an action.
  
  lemma `authRI_unique' references action 
    fact "AcceptR" (arity 8, Linear) 
  but no rule has such an action.
  
  lemma `authIR_unique' references action 
    fact "AcceptI" (arity 9, Linear) 
  but no rule has such an action.
  
  lemma `authIR_unique' references action 
    fact "AcceptI" (arity 9, Linear) 
  but no rule has such an action.

Subterm Convergence Warning
===========================

  User-defined equations must be convergent and have the finite variant property. The following equations are not subterm convergent. If you are sure that the set of equations is nevertheless convergent and has the finite variant property, you can ignore this warning and continue 

    aeadmalleable(aeadenc(m, r, k, aa), r2) = aeadenc(m, r2, k, aa)
   
 For more information, please refer to the manual : https://tamarin-prover.com/manual/master/book/010_modeling-issues.html 
*)

(*
Generated from:
Tamarin version 1.10.0
Maude version 2.7.1
Git revision: UNKNOWN, branch: UNKNOWN
Compiled at: 2024-10-30 14:56:23.355649243 UTC
*)
